public class com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer extends com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer
{
    private com.mycila.inject.internal.cglib.core.MethodInfo info;

    public void <init>(java.lang.reflect.Method)
    {
        com.mycila.inject.internal.asm.Type $r7, $r8, $r11, $r12;
        com.mycila.inject.internal.cglib.core.MethodInfo $r2, $r3, $r4, $r9;
        java.lang.StringBuffer $r14, $r15, $r16, $r19, $r20, $r21;
        int $i0, $i1;
        java.lang.String $r17, $r22;
        com.mycila.inject.internal.asm.Type[] $r6;
        java.lang.reflect.Method r1;
        com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer r0;
        boolean $z0, $z1, $z2;
        com.mycila.inject.internal.cglib.core.Signature $r5, $r10;
        java.lang.IllegalArgumentException $r13, $r18;

        r0 := @this: com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer;

        r1 := @parameter0: java.lang.reflect.Method;

        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: void <init>()>();

        $r2 = staticinvoke <com.mycila.inject.internal.cglib.core.ReflectUtils: com.mycila.inject.internal.cglib.core.MethodInfo getMethodInfo(java.lang.reflect.Member)>(r1);

        r0.<com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer: com.mycila.inject.internal.cglib.core.MethodInfo info> = $r2;

        $r3 = r0.<com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer: com.mycila.inject.internal.cglib.core.MethodInfo info>;

        $i0 = virtualinvoke $r3.<com.mycila.inject.internal.cglib.core.MethodInfo: int getModifiers()>();

        $z0 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: boolean isStatic(int)>($i0);

        if $z0 != 0 goto label1;

        $r13 = new java.lang.IllegalArgumentException;

        $r14 = new java.lang.StringBuffer;

        specialinvoke $r14.<java.lang.StringBuffer: void <init>()>();

        $r15 = virtualinvoke $r14.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.Object)>(r1);

        $r16 = virtualinvoke $r15.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>(" is not static");

        $r17 = virtualinvoke $r16.<java.lang.StringBuffer: java.lang.String toString()>();

        specialinvoke $r13.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r17);

        throw $r13;

     label1:
        $r4 = r0.<com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer: com.mycila.inject.internal.cglib.core.MethodInfo info>;

        $r5 = virtualinvoke $r4.<com.mycila.inject.internal.cglib.core.MethodInfo: com.mycila.inject.internal.cglib.core.Signature getSignature()>();

        $r6 = virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.Signature: com.mycila.inject.internal.asm.Type[] getArgumentTypes()>();

        $i1 = lengthof $r6;

        if $i1 != 1 goto label2;

        $r8 = $r6[0];

        $r7 = <com.mycila.inject.internal.cglib.core.Constants: com.mycila.inject.internal.asm.Type TYPE_CLASS>;

        $z1 = virtualinvoke $r8.<com.mycila.inject.internal.asm.Type: boolean equals(java.lang.Object)>($r7);

        if $z1 == 0 goto label2;

        $r9 = r0.<com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer: com.mycila.inject.internal.cglib.core.MethodInfo info>;

        $r10 = virtualinvoke $r9.<com.mycila.inject.internal.cglib.core.MethodInfo: com.mycila.inject.internal.cglib.core.Signature getSignature()>();

        $r11 = virtualinvoke $r10.<com.mycila.inject.internal.cglib.core.Signature: com.mycila.inject.internal.asm.Type getReturnType()>();

        $r12 = <com.mycila.inject.internal.asm.Type: com.mycila.inject.internal.asm.Type VOID_TYPE>;

        $z2 = virtualinvoke $r11.<com.mycila.inject.internal.asm.Type: boolean equals(java.lang.Object)>($r12);

        if $z2 != 0 goto label3;

     label2:
        $r18 = new java.lang.IllegalArgumentException;

        $r19 = new java.lang.StringBuffer;

        specialinvoke $r19.<java.lang.StringBuffer: void <init>()>();

        $r20 = virtualinvoke $r19.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.Object)>(r1);

        $r21 = virtualinvoke $r20.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>(" illegal signature");

        $r22 = virtualinvoke $r21.<java.lang.StringBuffer: java.lang.String toString()>();

        specialinvoke $r18.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r22);

        throw $r18;

     label3:
        return;
    }

    protected void init()
    {
        int $i0;
        com.mycila.inject.internal.cglib.core.CodeEmitter $r1;
        com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer r0;
        boolean $z0;
        com.mycila.inject.internal.cglib.core.MethodInfo $r2;

        r0 := @this: com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer;

        $i0 = virtualinvoke r0.<com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer: int getAccess()>();

        $z0 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: boolean isInterface(int)>($i0);

        if $z0 != 0 goto label1;

        $r1 = virtualinvoke r0.<com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer: com.mycila.inject.internal.cglib.core.CodeEmitter getStaticHook()>();

        staticinvoke <com.mycila.inject.internal.cglib.core.EmitUtils: void load_class_this(com.mycila.inject.internal.cglib.core.CodeEmitter)>($r1);

        $r2 = r0.<com.mycila.inject.internal.cglib.transform.impl.AddStaticInitTransformer: com.mycila.inject.internal.cglib.core.MethodInfo info>;

        virtualinvoke $r1.<com.mycila.inject.internal.cglib.core.CodeEmitter: void invoke(com.mycila.inject.internal.cglib.core.MethodInfo)>($r2);

     label1:
        return;
    }
}
