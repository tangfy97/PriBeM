public abstract class org.bouncycastle.crypto.util.Pack extends java.lang.Object
{

    public void <init>()
    {
        org.bouncycastle.crypto.util.Pack r0;

        r0 := @this: org.bouncycastle.crypto.util.Pack;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        return;
    }

    public static int bigEndianToInt(byte[], int)
    {
        byte[] r0;
        short $s2, $s5, $s8, $s18, $s20, $s22;
        byte $b0, $b1, $b4, $b7;
        int $i3, $i6, i9, i10, i11, i12, i13, i14, i15, i16, $i17, $i19, $i21, $i23;

        r0 := @parameter0: byte[];

        i9 := @parameter1: int;

        $b0 = r0[i9];

        $i17 = (int) $b0;

        i10 = $i17 << 24;

        i11 = i9 + 1;

        $b1 = r0[i11];

        $s18 = (short) $b1;

        $s2 = $s18 & 255;

        $i19 = (int) $s2;

        $i3 = $i19 << 16;

        i12 = i10 | $i3;

        i13 = i11 + 1;

        $b4 = r0[i13];

        $s20 = (short) $b4;

        $s5 = $s20 & 255;

        $i21 = (int) $s5;

        $i6 = $i21 << 8;

        i14 = i12 | $i6;

        i15 = i13 + 1;

        $b7 = r0[i15];

        $s22 = (short) $b7;

        $s8 = $s22 & 255;

        $i23 = (int) $s8;

        i16 = i14 | $i23;

        return i16;
    }

    public static void intToBigEndian(int, byte[], int)
    {
        byte[] r0;
        byte $b2, $b4, $b6, $b7;
        int i0, $i1, $i3, $i5, i8, i9, i10, i11;

        i0 := @parameter0: int;

        r0 := @parameter1: byte[];

        i8 := @parameter2: int;

        $i1 = i0 >>> 24;

        $b2 = (byte) $i1;

        r0[i8] = $b2;

        i9 = i8 + 1;

        $i3 = i0 >>> 16;

        $b4 = (byte) $i3;

        r0[i9] = $b4;

        i10 = i9 + 1;

        $i5 = i0 >>> 8;

        $b6 = (byte) $i5;

        r0[i10] = $b6;

        i11 = i10 + 1;

        $b7 = (byte) i0;

        r0[i11] = $b7;

        return;
    }

    public static long bigEndianToLong(byte[], int)
    {
        byte[] r0;
        long $l4, $l5, $l6, $l7, $l8, $l9;
        int i0, $i1, $i2, $i3;

        r0 := @parameter0: byte[];

        i0 := @parameter1: int;

        $i1 = staticinvoke <org.bouncycastle.crypto.util.Pack: int bigEndianToInt(byte[],int)>(r0, i0);

        $i2 = i0 + 4;

        $i3 = staticinvoke <org.bouncycastle.crypto.util.Pack: int bigEndianToInt(byte[],int)>(r0, $i2);

        $l4 = (long) $i1;

        $l5 = $l4 & 4294967295L;

        $l8 = $l5 << 32;

        $l6 = (long) $i3;

        $l7 = $l6 & 4294967295L;

        $l9 = $l8 | $l7;

        return $l9;
    }

    public static void longToBigEndian(long, byte[], int)
    {
        byte[] r0;
        long l0, $l1, $l4;
        int i2, $i3, $i5, $i6;

        l0 := @parameter0: long;

        r0 := @parameter1: byte[];

        i2 := @parameter2: int;

        $l1 = l0 >>> 32;

        $i3 = (int) $l1;

        staticinvoke <org.bouncycastle.crypto.util.Pack: void intToBigEndian(int,byte[],int)>($i3, r0, i2);

        $l4 = l0 & 4294967295L;

        $i6 = (int) $l4;

        $i5 = i2 + 4;

        staticinvoke <org.bouncycastle.crypto.util.Pack: void intToBigEndian(int,byte[],int)>($i6, r0, $i5);

        return;
    }
}
