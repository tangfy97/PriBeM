public class com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer extends com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer
{
    private static final java.lang.String CALLBACK_FIELD;
    private static final com.mycila.inject.internal.asm.Type CALLBACK;
    private static final com.mycila.inject.internal.asm.Type ENABLED;
    private static final com.mycila.inject.internal.cglib.core.Signature ENABLED_SET;
    private static final com.mycila.inject.internal.cglib.core.Signature ENABLED_GET;
    private com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter filter;

    public void <init>(com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter)
    {
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer r0;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter r1;

        r0 := @this: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer;

        r1 := @parameter0: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter;

        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: void <init>()>();

        r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter filter> = r1;

        return;
    }

    public void begin_class(int, int, java.lang.String, com.mycila.inject.internal.asm.Type, com.mycila.inject.internal.asm.Type[], java.lang.String)
    {
        com.mycila.inject.internal.cglib.core.Signature $r8, $r10;
        com.mycila.inject.internal.asm.Type r2, $r5, $r7;
        com.mycila.inject.internal.cglib.core.CodeEmitter $r9, $r11;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer r0;
        int i0, i1;
        java.lang.String r1, r4;
        com.mycila.inject.internal.asm.Type[] r3, $r6;
        boolean $z0;

        r0 := @this: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer;

        i1 := @parameter0: int;

        i0 := @parameter1: int;

        r1 := @parameter2: java.lang.String;

        r2 := @parameter3: com.mycila.inject.internal.asm.Type;

        r3 := @parameter4: com.mycila.inject.internal.asm.Type[];

        r4 := @parameter5: java.lang.String;

        $z0 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: boolean isInterface(int)>(i0);

        if $z0 != 0 goto label1;

        $r5 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type ENABLED>;

        $r6 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: com.mycila.inject.internal.asm.Type[] add(com.mycila.inject.internal.asm.Type[],com.mycila.inject.internal.asm.Type)>(r3, $r5);

        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: void begin_class(int,int,java.lang.String,com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.asm.Type[],java.lang.String)>(i1, i0, r1, r2, $r6, r4);

        $r7 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type CALLBACK>;

        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: void declare_field(int,java.lang.String,com.mycila.inject.internal.asm.Type,java.lang.Object)>(130, "$CGLIB_READ_WRITE_CALLBACK", $r7, null);

        $r8 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_GET>;

        $r9 = specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: com.mycila.inject.internal.cglib.core.CodeEmitter begin_method(int,com.mycila.inject.internal.cglib.core.Signature,com.mycila.inject.internal.asm.Type[])>(1, $r8, null);

        virtualinvoke $r9.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        virtualinvoke $r9.<com.mycila.inject.internal.cglib.core.CodeEmitter: void getfield(java.lang.String)>("$CGLIB_READ_WRITE_CALLBACK");

        virtualinvoke $r9.<com.mycila.inject.internal.cglib.core.CodeEmitter: void return_value()>();

        virtualinvoke $r9.<com.mycila.inject.internal.cglib.core.CodeEmitter: void end_method()>();

        $r10 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_SET>;

        $r11 = specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: com.mycila.inject.internal.cglib.core.CodeEmitter begin_method(int,com.mycila.inject.internal.cglib.core.Signature,com.mycila.inject.internal.asm.Type[])>(1, $r10, null);

        virtualinvoke $r11.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        virtualinvoke $r11.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_arg(int)>(0);

        virtualinvoke $r11.<com.mycila.inject.internal.cglib.core.CodeEmitter: void putfield(java.lang.String)>("$CGLIB_READ_WRITE_CALLBACK");

        virtualinvoke $r11.<com.mycila.inject.internal.cglib.core.CodeEmitter: void return_value()>();

        virtualinvoke $r11.<com.mycila.inject.internal.cglib.core.CodeEmitter: void end_method()>();

        goto label2;

     label1:
        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: void begin_class(int,int,java.lang.String,com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.asm.Type[],java.lang.String)>(i1, i0, r1, r2, r3, r4);

     label2:
        return;
    }

    public void declare_field(int, java.lang.String, com.mycila.inject.internal.asm.Type, java.lang.Object)
    {
        com.mycila.inject.internal.asm.Type r2, $r5, $r7;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer r0;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter $r4, $r6;
        int i0;
        java.lang.Object r3;
        java.lang.String r1;
        boolean $z0, $z1, $z2;

        r0 := @this: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer;

        i0 := @parameter0: int;

        r1 := @parameter1: java.lang.String;

        r2 := @parameter2: com.mycila.inject.internal.asm.Type;

        r3 := @parameter3: java.lang.Object;

        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: void declare_field(int,java.lang.String,com.mycila.inject.internal.asm.Type,java.lang.Object)>(i0, r1, r2, r3);

        $z0 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: boolean isStatic(int)>(i0);

        if $z0 != 0 goto label2;

        $r4 = r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter filter>;

        $r5 = virtualinvoke r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type getClassType()>();

        $z1 = interfaceinvoke $r4.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter: boolean acceptRead(com.mycila.inject.internal.asm.Type,java.lang.String)>($r5, r1);

        if $z1 == 0 goto label1;

        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: void addReadMethod(java.lang.String,com.mycila.inject.internal.asm.Type)>(r1, r2);

     label1:
        $r6 = r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter filter>;

        $r7 = virtualinvoke r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type getClassType()>();

        $z2 = interfaceinvoke $r6.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter: boolean acceptWrite(com.mycila.inject.internal.asm.Type,java.lang.String)>($r7, r1);

        if $z2 == 0 goto label2;

        specialinvoke r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: void addWriteMethod(java.lang.String,com.mycila.inject.internal.asm.Type)>(r1, r2);

     label2:
        return;
    }

    private void addReadMethod(java.lang.String, com.mycila.inject.internal.asm.Type)
    {
        com.mycila.inject.internal.cglib.core.Signature $r4, $r6, $r10, $r13;
        com.mycila.inject.internal.asm.Type r2, $r7, $r11, $r12;
        com.mycila.inject.internal.cglib.core.CodeEmitter $r5;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer r0;
        com.mycila.inject.internal.cglib.core.Local $r9;
        com.mycila.inject.internal.asm.Label $r8;
        java.lang.String r1, $r3;
        boolean $z0;

        r0 := @this: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer;

        r1 := @parameter0: java.lang.String;

        r2 := @parameter1: com.mycila.inject.internal.asm.Type;

        $r3 = virtualinvoke r2.<com.mycila.inject.internal.asm.Type: java.lang.String getDescriptor()>();

        $r4 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature readMethodSig(java.lang.String,java.lang.String)>(r1, $r3);

        $r5 = specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: com.mycila.inject.internal.cglib.core.CodeEmitter begin_method(int,com.mycila.inject.internal.cglib.core.Signature,com.mycila.inject.internal.asm.Type[])>(1, $r4, null);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void getfield(java.lang.String)>(r1);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        $r7 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type ENABLED>;

        $r6 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_GET>;

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void invoke_interface(com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.cglib.core.Signature)>($r7, $r6);

        $r8 = virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: com.mycila.inject.internal.asm.Label make_label()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void ifnonnull(com.mycila.inject.internal.asm.Label)>($r8);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void return_value()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void mark(com.mycila.inject.internal.asm.Label)>($r8);

        $r9 = virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: com.mycila.inject.internal.cglib.core.Local make_local(com.mycila.inject.internal.asm.Type)>(r2);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void store_local(com.mycila.inject.internal.cglib.core.Local)>($r9);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        $r11 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type ENABLED>;

        $r10 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_GET>;

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void invoke_interface(com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.cglib.core.Signature)>($r11, $r10);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void push(java.lang.String)>(r1);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_local(com.mycila.inject.internal.cglib.core.Local)>($r9);

        $r12 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type CALLBACK>;

        $r13 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature readCallbackSig(com.mycila.inject.internal.asm.Type)>(r2);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void invoke_interface(com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.cglib.core.Signature)>($r12, $r13);

        $z0 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: boolean isPrimitive(com.mycila.inject.internal.asm.Type)>(r2);

        if $z0 != 0 goto label1;

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void checkcast(com.mycila.inject.internal.asm.Type)>(r2);

     label1:
        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void return_value()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void end_method()>();

        return;
    }

    private void addWriteMethod(java.lang.String, com.mycila.inject.internal.asm.Type)
    {
        com.mycila.inject.internal.cglib.core.Signature $r4, $r6, $r9, $r12;
        com.mycila.inject.internal.asm.Type r2, $r7, $r10, $r11;
        com.mycila.inject.internal.cglib.core.CodeEmitter $r5;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer r0;
        com.mycila.inject.internal.asm.Label $r8, $r13;
        java.lang.String r1, $r3;
        boolean $z0;

        r0 := @this: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer;

        r1 := @parameter0: java.lang.String;

        r2 := @parameter1: com.mycila.inject.internal.asm.Type;

        $r3 = virtualinvoke r2.<com.mycila.inject.internal.asm.Type: java.lang.String getDescriptor()>();

        $r4 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature writeMethodSig(java.lang.String,java.lang.String)>(r1, $r3);

        $r5 = specialinvoke r0.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: com.mycila.inject.internal.cglib.core.CodeEmitter begin_method(int,com.mycila.inject.internal.cglib.core.Signature,com.mycila.inject.internal.asm.Type[])>(1, $r4, null);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void dup()>();

        $r7 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type ENABLED>;

        $r6 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_GET>;

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void invoke_interface(com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.cglib.core.Signature)>($r7, $r6);

        $r8 = virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: com.mycila.inject.internal.asm.Label make_label()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void ifnull(com.mycila.inject.internal.asm.Label)>($r8);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        $r10 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type ENABLED>;

        $r9 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_GET>;

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void invoke_interface(com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.cglib.core.Signature)>($r10, $r9);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void push(java.lang.String)>(r1);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_this()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void getfield(java.lang.String)>(r1);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_arg(int)>(0);

        $r11 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type CALLBACK>;

        $r12 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature writeCallbackSig(com.mycila.inject.internal.asm.Type)>(r2);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void invoke_interface(com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.cglib.core.Signature)>($r11, $r12);

        $z0 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: boolean isPrimitive(com.mycila.inject.internal.asm.Type)>(r2);

        if $z0 != 0 goto label1;

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void checkcast(com.mycila.inject.internal.asm.Type)>(r2);

     label1:
        $r13 = virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: com.mycila.inject.internal.asm.Label make_label()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void goTo(com.mycila.inject.internal.asm.Label)>($r13);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void mark(com.mycila.inject.internal.asm.Label)>($r8);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void load_arg(int)>(0);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void mark(com.mycila.inject.internal.asm.Label)>($r13);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void putfield(java.lang.String)>(r1);

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void return_value()>();

        virtualinvoke $r5.<com.mycila.inject.internal.cglib.core.CodeEmitter: void end_method()>();

        return;
    }

    public com.mycila.inject.internal.cglib.core.CodeEmitter begin_method(int, com.mycila.inject.internal.cglib.core.Signature, com.mycila.inject.internal.asm.Type[])
    {
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer$1 $r0;
        com.mycila.inject.internal.cglib.core.Signature r2;
        int i0;
        com.mycila.inject.internal.cglib.core.CodeEmitter $r4;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer r1;
        com.mycila.inject.internal.asm.Type[] r3;

        r1 := @this: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer;

        i0 := @parameter0: int;

        r2 := @parameter1: com.mycila.inject.internal.cglib.core.Signature;

        r3 := @parameter2: com.mycila.inject.internal.asm.Type[];

        $r0 = new com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer$1;

        $r4 = specialinvoke r1.<com.mycila.inject.internal.cglib.transform.ClassEmitterTransformer: com.mycila.inject.internal.cglib.core.CodeEmitter begin_method(int,com.mycila.inject.internal.cglib.core.Signature,com.mycila.inject.internal.asm.Type[])>(i0, r2, r3);

        specialinvoke $r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer$1: void <init>(com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer,com.mycila.inject.internal.cglib.core.CodeEmitter)>(r1, $r4);

        return $r0;
    }

    private static com.mycila.inject.internal.cglib.core.Signature readMethodSig(java.lang.String, java.lang.String)
    {
        com.mycila.inject.internal.cglib.core.Signature $r0;
        java.lang.StringBuffer $r1, $r2, $r4, $r6, $r7, $r9;
        java.lang.String r3, $r5, r8, $r10;

        r3 := @parameter0: java.lang.String;

        r8 := @parameter1: java.lang.String;

        $r0 = new com.mycila.inject.internal.cglib.core.Signature;

        $r1 = new java.lang.StringBuffer;

        specialinvoke $r1.<java.lang.StringBuffer: void <init>()>();

        $r2 = virtualinvoke $r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>("$cglib_read_");

        $r4 = virtualinvoke $r2.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>(r3);

        $r5 = virtualinvoke $r4.<java.lang.StringBuffer: java.lang.String toString()>();

        $r6 = new java.lang.StringBuffer;

        specialinvoke $r6.<java.lang.StringBuffer: void <init>()>();

        $r7 = virtualinvoke $r6.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>("()");

        $r9 = virtualinvoke $r7.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>(r8);

        $r10 = virtualinvoke $r9.<java.lang.StringBuffer: java.lang.String toString()>();

        specialinvoke $r0.<com.mycila.inject.internal.cglib.core.Signature: void <init>(java.lang.String,java.lang.String)>($r5, $r10);

        return $r0;
    }

    private static com.mycila.inject.internal.cglib.core.Signature writeMethodSig(java.lang.String, java.lang.String)
    {
        com.mycila.inject.internal.cglib.core.Signature $r0;
        java.lang.StringBuffer $r1, $r2, $r4, $r6, $r7, $r9, $r10;
        java.lang.String r3, $r5, r8, $r11;

        r3 := @parameter0: java.lang.String;

        r8 := @parameter1: java.lang.String;

        $r0 = new com.mycila.inject.internal.cglib.core.Signature;

        $r1 = new java.lang.StringBuffer;

        specialinvoke $r1.<java.lang.StringBuffer: void <init>()>();

        $r2 = virtualinvoke $r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>("$cglib_write_");

        $r4 = virtualinvoke $r2.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>(r3);

        $r5 = virtualinvoke $r4.<java.lang.StringBuffer: java.lang.String toString()>();

        $r6 = new java.lang.StringBuffer;

        specialinvoke $r6.<java.lang.StringBuffer: void <init>()>();

        $r7 = virtualinvoke $r6.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>("(");

        $r9 = virtualinvoke $r7.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>(r8);

        $r10 = virtualinvoke $r9.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>(")V");

        $r11 = virtualinvoke $r10.<java.lang.StringBuffer: java.lang.String toString()>();

        specialinvoke $r0.<com.mycila.inject.internal.cglib.core.Signature: void <init>(java.lang.String,java.lang.String)>($r5, $r11);

        return $r0;
    }

    private static com.mycila.inject.internal.cglib.core.Signature readCallbackSig(com.mycila.inject.internal.asm.Type)
    {
        com.mycila.inject.internal.cglib.core.Signature $r2;
        com.mycila.inject.internal.asm.Type r0, $r1, $r9, $r10;
        java.lang.StringBuffer $r3, $r4, $r6;
        java.lang.String $r5, $r7;
        com.mycila.inject.internal.asm.Type[] $r8;

        r0 := @parameter0: com.mycila.inject.internal.asm.Type;

        $r1 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type remap(com.mycila.inject.internal.asm.Type)>(r0);

        $r2 = new com.mycila.inject.internal.cglib.core.Signature;

        $r3 = new java.lang.StringBuffer;

        specialinvoke $r3.<java.lang.StringBuffer: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>("read");

        $r5 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: java.lang.String callbackName(com.mycila.inject.internal.asm.Type)>($r1);

        $r6 = virtualinvoke $r4.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>($r5);

        $r7 = virtualinvoke $r6.<java.lang.StringBuffer: java.lang.String toString()>();

        $r8 = newarray (com.mycila.inject.internal.asm.Type)[3];

        $r9 = <com.mycila.inject.internal.cglib.core.Constants: com.mycila.inject.internal.asm.Type TYPE_OBJECT>;

        $r8[0] = $r9;

        $r10 = <com.mycila.inject.internal.cglib.core.Constants: com.mycila.inject.internal.asm.Type TYPE_STRING>;

        $r8[1] = $r10;

        $r8[2] = $r1;

        specialinvoke $r2.<com.mycila.inject.internal.cglib.core.Signature: void <init>(java.lang.String,com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.asm.Type[])>($r7, $r1, $r8);

        return $r2;
    }

    private static com.mycila.inject.internal.cglib.core.Signature writeCallbackSig(com.mycila.inject.internal.asm.Type)
    {
        com.mycila.inject.internal.cglib.core.Signature $r2;
        com.mycila.inject.internal.asm.Type r0, $r1, $r9, $r10;
        java.lang.StringBuffer $r3, $r4, $r6;
        java.lang.String $r5, $r7;
        com.mycila.inject.internal.asm.Type[] $r8;

        r0 := @parameter0: com.mycila.inject.internal.asm.Type;

        $r1 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type remap(com.mycila.inject.internal.asm.Type)>(r0);

        $r2 = new com.mycila.inject.internal.cglib.core.Signature;

        $r3 = new java.lang.StringBuffer;

        specialinvoke $r3.<java.lang.StringBuffer: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>("write");

        $r5 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: java.lang.String callbackName(com.mycila.inject.internal.asm.Type)>($r1);

        $r6 = virtualinvoke $r4.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>($r5);

        $r7 = virtualinvoke $r6.<java.lang.StringBuffer: java.lang.String toString()>();

        $r8 = newarray (com.mycila.inject.internal.asm.Type)[4];

        $r9 = <com.mycila.inject.internal.cglib.core.Constants: com.mycila.inject.internal.asm.Type TYPE_OBJECT>;

        $r8[0] = $r9;

        $r10 = <com.mycila.inject.internal.cglib.core.Constants: com.mycila.inject.internal.asm.Type TYPE_STRING>;

        $r8[1] = $r10;

        $r8[2] = $r1;

        $r8[3] = $r1;

        specialinvoke $r2.<com.mycila.inject.internal.cglib.core.Signature: void <init>(java.lang.String,com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.asm.Type[])>($r7, $r1, $r8);

        return $r2;
    }

    private static com.mycila.inject.internal.asm.Type remap(com.mycila.inject.internal.asm.Type)
    {
        int $i0;
        com.mycila.inject.internal.asm.Type r0, $r1;

        r0 := @parameter0: com.mycila.inject.internal.asm.Type;

        $i0 = virtualinvoke r0.<com.mycila.inject.internal.asm.Type: int getSort()>();

        lookupswitch($i0)
        {
            case 9: goto label1;
            case 10: goto label1;
            default: goto label2;
        };

     label1:
        $r1 = <com.mycila.inject.internal.cglib.core.Constants: com.mycila.inject.internal.asm.Type TYPE_OBJECT>;

        return $r1;

     label2:
        return r0;
    }

    private static java.lang.String callbackName(com.mycila.inject.internal.asm.Type)
    {
        com.mycila.inject.internal.asm.Type r0, $r1;
        java.lang.String $r2, $r3;

        r0 := @parameter0: com.mycila.inject.internal.asm.Type;

        $r1 = <com.mycila.inject.internal.cglib.core.Constants: com.mycila.inject.internal.asm.Type TYPE_OBJECT>;

        if r0 != $r1 goto label1;

        $r3 = "Object";

        goto label2;

     label1:
        $r2 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: java.lang.String getClassName(com.mycila.inject.internal.asm.Type)>(r0);

        $r3 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: java.lang.String upperFirst(java.lang.String)>($r2);

     label2:
        return $r3;
    }

    static com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter access$000(com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer)
    {
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer r0;
        com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter $r1;

        r0 := @parameter0: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer;

        $r1 = r0.<com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.transform.impl.InterceptFieldFilter filter>;

        return $r1;
    }

    static com.mycila.inject.internal.cglib.core.Signature access$100(java.lang.String, java.lang.String)
    {
        java.lang.String r0, r1;
        com.mycila.inject.internal.cglib.core.Signature $r2;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.String;

        $r2 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature readMethodSig(java.lang.String,java.lang.String)>(r0, r1);

        return $r2;
    }

    static com.mycila.inject.internal.cglib.core.Signature access$200(java.lang.String, java.lang.String)
    {
        java.lang.String r0, r1;
        com.mycila.inject.internal.cglib.core.Signature $r2;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.String;

        $r2 = staticinvoke <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature writeMethodSig(java.lang.String,java.lang.String)>(r0, r1);

        return $r2;
    }

    static void <clinit>()
    {
        com.mycila.inject.internal.cglib.core.Signature $r2, $r6;
        com.mycila.inject.internal.asm.Type $r0, $r1, $r4, $r5, $r8;
        com.mycila.inject.internal.asm.Type[] $r3, $r7;

        <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: java.lang.String CALLBACK_FIELD> = "$CGLIB_READ_WRITE_CALLBACK";

        $r0 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: com.mycila.inject.internal.asm.Type parseType(java.lang.String)>("com.mycila.inject.internal.cglib.transform.impl.InterceptFieldCallback");

        <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type CALLBACK> = $r0;

        $r1 = staticinvoke <com.mycila.inject.internal.cglib.core.TypeUtils: com.mycila.inject.internal.asm.Type parseType(java.lang.String)>("com.mycila.inject.internal.cglib.transform.impl.InterceptFieldEnabled");

        <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type ENABLED> = $r1;

        $r2 = new com.mycila.inject.internal.cglib.core.Signature;

        $r5 = <com.mycila.inject.internal.asm.Type: com.mycila.inject.internal.asm.Type VOID_TYPE>;

        $r3 = newarray (com.mycila.inject.internal.asm.Type)[1];

        $r4 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type CALLBACK>;

        $r3[0] = $r4;

        specialinvoke $r2.<com.mycila.inject.internal.cglib.core.Signature: void <init>(java.lang.String,com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.asm.Type[])>("setInterceptFieldCallback", $r5, $r3);

        <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_SET> = $r2;

        $r6 = new com.mycila.inject.internal.cglib.core.Signature;

        $r8 = <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.asm.Type CALLBACK>;

        $r7 = newarray (com.mycila.inject.internal.asm.Type)[0];

        specialinvoke $r6.<com.mycila.inject.internal.cglib.core.Signature: void <init>(java.lang.String,com.mycila.inject.internal.asm.Type,com.mycila.inject.internal.asm.Type[])>("getInterceptFieldCallback", $r8, $r7);

        <com.mycila.inject.internal.cglib.transform.impl.InterceptFieldTransformer: com.mycila.inject.internal.cglib.core.Signature ENABLED_GET> = $r6;

        return;
    }
}
