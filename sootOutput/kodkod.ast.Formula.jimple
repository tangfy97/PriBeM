public abstract class kodkod.ast.Formula extends kodkod.ast.Node
{
    public static final kodkod.ast.Formula TRUE;
    public static final kodkod.ast.Formula FALSE;
    private static int[] $SWITCH_TABLE$kodkod$ast$operator$FormulaOperator;

    static void <clinit>()
    {
        kodkod.ast.Formula$1 $r0;
        kodkod.ast.Formula$2 $r1;

        $r0 = new kodkod.ast.Formula$1;

        specialinvoke $r0.<kodkod.ast.Formula$1: void <init>(boolean)>(1);

        <kodkod.ast.Formula: kodkod.ast.Formula TRUE> = $r0;

        $r1 = new kodkod.ast.Formula$2;

        specialinvoke $r1.<kodkod.ast.Formula$2: void <init>(boolean)>(0);

        <kodkod.ast.Formula: kodkod.ast.Formula FALSE> = $r1;

        return;
    }

    void <init>()
    {
        kodkod.ast.Formula r0;

        r0 := @this: kodkod.ast.Formula;

        specialinvoke r0.<kodkod.ast.Node: void <init>()>();

        return;
    }

    public static kodkod.ast.Formula constant(boolean)
    {
        boolean z0;
        kodkod.ast.Formula $r0;

        z0 := @parameter0: boolean;

        if z0 == 0 goto label1;

        $r0 = <kodkod.ast.Formula: kodkod.ast.Formula TRUE>;

        goto label2;

     label1:
        $r0 = <kodkod.ast.Formula: kodkod.ast.Formula FALSE>;

     label2:
        return $r0;
    }

    public final kodkod.ast.Formula and(kodkod.ast.Formula)
    {
        kodkod.ast.Formula r0, r1, $r3;
        kodkod.ast.operator.FormulaOperator $r2;

        r0 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.Formula;

        $r2 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator AND>;

        $r3 = virtualinvoke r0.<kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula)>($r2, r1);

        return $r3;
    }

    public final kodkod.ast.Formula or(kodkod.ast.Formula)
    {
        kodkod.ast.Formula r0, r1, $r3;
        kodkod.ast.operator.FormulaOperator $r2;

        r0 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.Formula;

        $r2 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator OR>;

        $r3 = virtualinvoke r0.<kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula)>($r2, r1);

        return $r3;
    }

    public final kodkod.ast.Formula iff(kodkod.ast.Formula)
    {
        kodkod.ast.Formula r0, r1, $r3;
        kodkod.ast.operator.FormulaOperator $r2;

        r0 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.Formula;

        $r2 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator IFF>;

        $r3 = virtualinvoke r0.<kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula)>($r2, r1);

        return $r3;
    }

    public final kodkod.ast.Formula implies(kodkod.ast.Formula)
    {
        kodkod.ast.Formula r0, r1, $r3;
        kodkod.ast.operator.FormulaOperator $r2;

        r0 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.Formula;

        $r2 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator IMPLIES>;

        $r3 = virtualinvoke r0.<kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula)>($r2, r1);

        return $r3;
    }

    public final kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator, kodkod.ast.Formula)
    {
        kodkod.ast.BinaryFormula $r0;
        kodkod.ast.Formula r1, r3;
        kodkod.ast.operator.FormulaOperator r2;

        r1 := @this: kodkod.ast.Formula;

        r2 := @parameter0: kodkod.ast.operator.FormulaOperator;

        r3 := @parameter1: kodkod.ast.Formula;

        $r0 = new kodkod.ast.BinaryFormula;

        specialinvoke $r0.<kodkod.ast.BinaryFormula: void <init>(kodkod.ast.Formula,kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula)>(r1, r2, r3);

        return $r0;
    }

    public static transient kodkod.ast.Formula and(kodkod.ast.Formula[])
    {
        kodkod.ast.Formula[] r0;
        kodkod.ast.operator.FormulaOperator $r1;
        kodkod.ast.Formula $r2;

        r0 := @parameter0: kodkod.ast.Formula[];

        $r1 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator AND>;

        $r2 = staticinvoke <kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula[])>($r1, r0);

        return $r2;
    }

    public static kodkod.ast.Formula and(java.util.Collection)
    {
        java.util.Collection r0;
        kodkod.ast.operator.FormulaOperator $r1;
        kodkod.ast.Formula $r2;

        r0 := @parameter0: java.util.Collection;

        $r1 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator AND>;

        $r2 = staticinvoke <kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,java.util.Collection)>($r1, r0);

        return $r2;
    }

    public static transient kodkod.ast.Formula or(kodkod.ast.Formula[])
    {
        kodkod.ast.Formula[] r0;
        kodkod.ast.operator.FormulaOperator $r1;
        kodkod.ast.Formula $r2;

        r0 := @parameter0: kodkod.ast.Formula[];

        $r1 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator OR>;

        $r2 = staticinvoke <kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula[])>($r1, r0);

        return $r2;
    }

    public static kodkod.ast.Formula or(java.util.Collection)
    {
        java.util.Collection r0;
        kodkod.ast.operator.FormulaOperator $r1;
        kodkod.ast.Formula $r2;

        r0 := @parameter0: java.util.Collection;

        $r1 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator OR>;

        $r2 = staticinvoke <kodkod.ast.Formula: kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator,java.util.Collection)>($r1, r0);

        return $r2;
    }

    public static transient kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator, kodkod.ast.Formula[])
    {
        kodkod.ast.BinaryFormula $r1;
        java.lang.Object[] $r16;
        kodkod.ast.Formula[] r0, $r15, $r17;
        int[] $r6;
        kodkod.ast.operator.FormulaOperator r2;
        int $i0, $i1, $i2, $i3;
        java.lang.String $r11, $r13;
        kodkod.ast.NaryFormula $r14;
        kodkod.ast.Formula $r3, $r4, $r5, $r7, $r8;
        java.lang.IllegalArgumentException $r9;
        java.lang.StringBuilder $r10, $r12;

        r2 := @parameter0: kodkod.ast.operator.FormulaOperator;

        r0 := @parameter1: kodkod.ast.Formula[];

        $i0 = lengthof r0;

        tableswitch($i0)
        {
            case 0: goto label1;
            case 1: goto label5;
            case 2: goto label6;
            default: goto label7;
        };

     label1:
        $r6 = staticinvoke <kodkod.ast.Formula: int[] $SWITCH_TABLE$kodkod$ast$operator$FormulaOperator()>();

        $i1 = virtualinvoke r2.<kodkod.ast.operator.FormulaOperator: int ordinal()>();

        $i2 = $r6[$i1];

        tableswitch($i2)
        {
            case 0: goto label2;
            case 1: goto label3;
            default: goto label4;
        };

     label2:
        $r8 = <kodkod.ast.Formula: kodkod.ast.Formula TRUE>;

        return $r8;

     label3:
        $r7 = <kodkod.ast.Formula: kodkod.ast.Formula FALSE>;

        return $r7;

     label4:
        $r9 = new java.lang.IllegalArgumentException;

        $r10 = new java.lang.StringBuilder;

        specialinvoke $r10.<java.lang.StringBuilder: void <init>(java.lang.String)>("Expected at least one argument: ");

        $r11 = staticinvoke <java.util.Arrays: java.lang.String toString(java.lang.Object[])>(r0);

        $r12 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r11);

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r9.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r13);

        throw $r9;

     label5:
        $r5 = r0[0];

        return $r5;

     label6:
        $r1 = new kodkod.ast.BinaryFormula;

        $r4 = r0[0];

        $r3 = r0[1];

        specialinvoke $r1.<kodkod.ast.BinaryFormula: void <init>(kodkod.ast.Formula,kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula)>($r4, r2, $r3);

        return $r1;

     label7:
        $r14 = new kodkod.ast.NaryFormula;

        $i3 = lengthof r0;

        $r15 = newarray (kodkod.ast.Formula)[$i3];

        $r16 = staticinvoke <kodkod.util.collections.Containers: java.lang.Object[] copy(java.lang.Object[],java.lang.Object[])>(r0, $r15);

        $r17 = (kodkod.ast.Formula[]) $r16;

        specialinvoke $r14.<kodkod.ast.NaryFormula: void <init>(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula[])>(r2, $r17);

        return $r14;
    }

    public static kodkod.ast.Formula compose(kodkod.ast.operator.FormulaOperator, java.util.Collection)
    {
        kodkod.ast.BinaryFormula $r2;
        java.lang.Object[] $r20;
        kodkod.ast.Formula[] $r19, $r21;
        int[] $r11;
        kodkod.ast.operator.FormulaOperator r4;
        int $i0, $i1, $i2, $i3;
        java.lang.String $r17;
        kodkod.ast.NaryFormula $r18;
        java.util.Iterator $r1, $r8;
        java.util.Collection r0;
        kodkod.ast.Formula $r5, $r7, $r10, $r12, $r13;
        java.lang.IllegalArgumentException $r14;
        java.lang.Object $r3, $r6, $r9;
        java.lang.StringBuilder $r15, $r16;

        r4 := @parameter0: kodkod.ast.operator.FormulaOperator;

        r0 := @parameter1: java.util.Collection;

        $i0 = interfaceinvoke r0.<java.util.Collection: int size()>();

        tableswitch($i0)
        {
            case 0: goto label1;
            case 1: goto label5;
            case 2: goto label6;
            default: goto label7;
        };

     label1:
        $r11 = staticinvoke <kodkod.ast.Formula: int[] $SWITCH_TABLE$kodkod$ast$operator$FormulaOperator()>();

        $i1 = virtualinvoke r4.<kodkod.ast.operator.FormulaOperator: int ordinal()>();

        $i2 = $r11[$i1];

        tableswitch($i2)
        {
            case 0: goto label2;
            case 1: goto label3;
            default: goto label4;
        };

     label2:
        $r13 = <kodkod.ast.Formula: kodkod.ast.Formula TRUE>;

        return $r13;

     label3:
        $r12 = <kodkod.ast.Formula: kodkod.ast.Formula FALSE>;

        return $r12;

     label4:
        $r14 = new java.lang.IllegalArgumentException;

        $r15 = new java.lang.StringBuilder;

        specialinvoke $r15.<java.lang.StringBuilder: void <init>(java.lang.String)>("Expected at least one argument: ");

        $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r14.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r17);

        throw $r14;

     label5:
        $r8 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();

        $r9 = interfaceinvoke $r8.<java.util.Iterator: java.lang.Object next()>();

        $r10 = (kodkod.ast.Formula) $r9;

        return $r10;

     label6:
        $r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();

        $r2 = new kodkod.ast.BinaryFormula;

        $r3 = interfaceinvoke $r1.<java.util.Iterator: java.lang.Object next()>();

        $r5 = (kodkod.ast.Formula) $r3;

        $r6 = interfaceinvoke $r1.<java.util.Iterator: java.lang.Object next()>();

        $r7 = (kodkod.ast.Formula) $r6;

        specialinvoke $r2.<kodkod.ast.BinaryFormula: void <init>(kodkod.ast.Formula,kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula)>($r5, r4, $r7);

        return $r2;

     label7:
        $r18 = new kodkod.ast.NaryFormula;

        $i3 = interfaceinvoke r0.<java.util.Collection: int size()>();

        $r19 = newarray (kodkod.ast.Formula)[$i3];

        $r20 = interfaceinvoke r0.<java.util.Collection: java.lang.Object[] toArray(java.lang.Object[])>($r19);

        $r21 = (kodkod.ast.Formula[]) $r20;

        specialinvoke $r18.<kodkod.ast.NaryFormula: void <init>(kodkod.ast.operator.FormulaOperator,kodkod.ast.Formula[])>(r4, $r21);

        return $r18;
    }

    public final kodkod.ast.Formula forAll(kodkod.ast.Decls)
    {
        kodkod.ast.Formula r0, $r3;
        kodkod.ast.Decls r1;
        kodkod.ast.operator.Quantifier $r2;

        r0 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.Decls;

        $r2 = <kodkod.ast.operator.Quantifier: kodkod.ast.operator.Quantifier ALL>;

        $r3 = virtualinvoke r0.<kodkod.ast.Formula: kodkod.ast.Formula quantify(kodkod.ast.operator.Quantifier,kodkod.ast.Decls)>($r2, r1);

        return $r3;
    }

    public final kodkod.ast.Formula forSome(kodkod.ast.Decls)
    {
        kodkod.ast.Formula r0, $r3;
        kodkod.ast.Decls r1;
        kodkod.ast.operator.Quantifier $r2;

        r0 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.Decls;

        $r2 = <kodkod.ast.operator.Quantifier: kodkod.ast.operator.Quantifier SOME>;

        $r3 = virtualinvoke r0.<kodkod.ast.Formula: kodkod.ast.Formula quantify(kodkod.ast.operator.Quantifier,kodkod.ast.Decls)>($r2, r1);

        return $r3;
    }

    public final kodkod.ast.Formula quantify(kodkod.ast.operator.Quantifier, kodkod.ast.Decls)
    {
        kodkod.ast.QuantifiedFormula $r0;
        kodkod.ast.Formula r3;
        kodkod.ast.Decls r2;
        kodkod.ast.operator.Quantifier r1;

        r3 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.operator.Quantifier;

        r2 := @parameter1: kodkod.ast.Decls;

        $r0 = new kodkod.ast.QuantifiedFormula;

        specialinvoke $r0.<kodkod.ast.QuantifiedFormula: void <init>(kodkod.ast.operator.Quantifier,kodkod.ast.Decls,kodkod.ast.Formula)>(r1, r2, r3);

        return $r0;
    }

    public final kodkod.ast.Expression comprehension(kodkod.ast.Decls)
    {
        kodkod.ast.Decls r1;
        kodkod.ast.Comprehension $r0;
        kodkod.ast.Formula r2;

        r2 := @this: kodkod.ast.Formula;

        r1 := @parameter0: kodkod.ast.Decls;

        $r0 = new kodkod.ast.Comprehension;

        specialinvoke $r0.<kodkod.ast.Comprehension: void <init>(kodkod.ast.Decls,kodkod.ast.Formula)>(r1, r2);

        return $r0;
    }

    public final kodkod.ast.Expression thenElse(kodkod.ast.Expression, kodkod.ast.Expression)
    {
        kodkod.ast.Formula r1;
        kodkod.ast.Expression r2, r3;
        kodkod.ast.IfExpression $r0;

        r1 := @this: kodkod.ast.Formula;

        r2 := @parameter0: kodkod.ast.Expression;

        r3 := @parameter1: kodkod.ast.Expression;

        $r0 = new kodkod.ast.IfExpression;

        specialinvoke $r0.<kodkod.ast.IfExpression: void <init>(kodkod.ast.Formula,kodkod.ast.Expression,kodkod.ast.Expression)>(r1, r2, r3);

        return $r0;
    }

    public final kodkod.ast.IntExpression thenElse(kodkod.ast.IntExpression, kodkod.ast.IntExpression)
    {
        kodkod.ast.IntExpression r2, r3;
        kodkod.ast.IfIntExpression $r0;
        kodkod.ast.Formula r1;

        r1 := @this: kodkod.ast.Formula;

        r2 := @parameter0: kodkod.ast.IntExpression;

        r3 := @parameter1: kodkod.ast.IntExpression;

        $r0 = new kodkod.ast.IfIntExpression;

        specialinvoke $r0.<kodkod.ast.IfIntExpression: void <init>(kodkod.ast.Formula,kodkod.ast.IntExpression,kodkod.ast.IntExpression)>(r1, r2, r3);

        return $r0;
    }

    public final kodkod.ast.Formula not()
    {
        kodkod.ast.NotFormula $r0;
        kodkod.ast.Formula r1;

        r1 := @this: kodkod.ast.Formula;

        $r0 = new kodkod.ast.NotFormula;

        specialinvoke $r0.<kodkod.ast.NotFormula: void <init>(kodkod.ast.Formula)>(r1);

        return $r0;
    }

    public abstract java.lang.Object accept(kodkod.ast.visitor.ReturnVisitor);

    static int[] $SWITCH_TABLE$kodkod$ast$operator$FormulaOperator()
    {
        java.lang.NoSuchFieldError $r7, $r8, $r9, $r10;
        int[] $r0, r2;
        kodkod.ast.operator.FormulaOperator $r3, $r4, $r5, $r6;
        int $i0, $i1, $i2, $i3, $i4;
        kodkod.ast.operator.FormulaOperator[] $r1;

        $r0 = <kodkod.ast.Formula: int[] $SWITCH_TABLE$kodkod$ast$operator$FormulaOperator>;

        if $r0 == null goto label01;

        return $r0;

     label01:
        $r1 = staticinvoke <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator[] values()>();

        $i0 = lengthof $r1;

        r2 = newarray (int)[$i0];

     label02:
        $r3 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator AND>;

        $i1 = virtualinvoke $r3.<kodkod.ast.operator.FormulaOperator: int ordinal()>();

        r2[$i1] = 0;

     label03:
        goto label05;

     label04:
        $r10 := @caughtexception;

     label05:
        $r4 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator IFF>;

        $i2 = virtualinvoke $r4.<kodkod.ast.operator.FormulaOperator: int ordinal()>();

        r2[$i2] = 2;

     label06:
        goto label08;

     label07:
        $r9 := @caughtexception;

     label08:
        $r5 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator IMPLIES>;

        $i3 = virtualinvoke $r5.<kodkod.ast.operator.FormulaOperator: int ordinal()>();

        r2[$i3] = 3;

     label09:
        goto label11;

     label10:
        $r8 := @caughtexception;

     label11:
        $r6 = <kodkod.ast.operator.FormulaOperator: kodkod.ast.operator.FormulaOperator OR>;

        $i4 = virtualinvoke $r6.<kodkod.ast.operator.FormulaOperator: int ordinal()>();

        r2[$i4] = 1;

     label12:
        goto label14;

     label13:
        $r7 := @caughtexception;

     label14:
        <kodkod.ast.Formula: int[] $SWITCH_TABLE$kodkod$ast$operator$FormulaOperator> = r2;

        return r2;

        catch java.lang.NoSuchFieldError from label02 to label03 with label04;
        catch java.lang.NoSuchFieldError from label05 to label06 with label07;
        catch java.lang.NoSuchFieldError from label08 to label09 with label10;
        catch java.lang.NoSuchFieldError from label11 to label12 with label13;
    }
}
