final class org.apache.lucene.store.MMapDirectory$MMapIndexInput extends org.apache.lucene.store.ByteBufferIndexInput
{
    private final boolean useUnmapHack;
    final org.apache.lucene.store.MMapDirectory this$0;

    void <init>(org.apache.lucene.store.MMapDirectory, java.lang.String, java.io.RandomAccessFile) throws java.io.IOException
    {
        java.io.RandomAccessFile r3;
        java.nio.ByteBuffer[] $r4;
        org.apache.lucene.store.MMapDirectory r1;
        long $l0, $l1;
        org.apache.lucene.store.MMapDirectory$MMapIndexInput r0;
        int $i2;
        java.lang.String r2;
        boolean $z0, $z1;

        r0 := @this: org.apache.lucene.store.MMapDirectory$MMapIndexInput;

        r1 := @parameter0: org.apache.lucene.store.MMapDirectory;

        r2 := @parameter1: java.lang.String;

        r3 := @parameter2: java.io.RandomAccessFile;

        r0.<org.apache.lucene.store.MMapDirectory$MMapIndexInput: org.apache.lucene.store.MMapDirectory this$0> = r1;

        $l0 = virtualinvoke r3.<java.io.RandomAccessFile: long length()>();

        $r4 = virtualinvoke r1.<org.apache.lucene.store.MMapDirectory: java.nio.ByteBuffer[] map(java.io.RandomAccessFile,long,long)>(r3, 0L, $l0);

        $l1 = virtualinvoke r3.<java.io.RandomAccessFile: long length()>();

        $i2 = r1.<org.apache.lucene.store.MMapDirectory: int chunkSizePower>;

        $z0 = virtualinvoke r1.<org.apache.lucene.store.MMapDirectory: boolean getUseUnmap()>();

        specialinvoke r0.<org.apache.lucene.store.ByteBufferIndexInput: void <init>(java.lang.String,java.nio.ByteBuffer[],long,int,boolean)>(r2, $r4, $l1, $i2, $z0);

        $z1 = virtualinvoke r1.<org.apache.lucene.store.MMapDirectory: boolean getUseUnmap()>();

        r0.<org.apache.lucene.store.MMapDirectory$MMapIndexInput: boolean useUnmapHack> = $z1;

        return;
    }

    protected void freeBuffer(java.nio.ByteBuffer) throws java.io.IOException
    {
        java.lang.Throwable $r5;
        org.apache.lucene.store.MMapDirectory$MMapIndexInput r0;
        java.security.PrivilegedActionException $r3;
        java.io.IOException $r4;
        org.apache.lucene.store.MMapDirectory$MMapIndexInput$1 $r1;
        java.nio.ByteBuffer r2;
        boolean $z0;

        r0 := @this: org.apache.lucene.store.MMapDirectory$MMapIndexInput;

        r2 := @parameter0: java.nio.ByteBuffer;

        $z0 = r0.<org.apache.lucene.store.MMapDirectory$MMapIndexInput: boolean useUnmapHack>;

        if $z0 == 0 goto label4;

     label1:
        $r1 = new org.apache.lucene.store.MMapDirectory$MMapIndexInput$1;

        specialinvoke $r1.<org.apache.lucene.store.MMapDirectory$MMapIndexInput$1: void <init>(org.apache.lucene.store.MMapDirectory$MMapIndexInput,java.nio.ByteBuffer)>(r0, r2);

        staticinvoke <java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>($r1);

     label2:
        goto label4;

     label3:
        $r3 := @caughtexception;

        $r4 = new java.io.IOException;

        specialinvoke $r4.<java.io.IOException: void <init>(java.lang.String)>("unable to unmap the mapped buffer");

        $r5 = virtualinvoke $r3.<java.security.PrivilegedActionException: java.lang.Throwable getCause()>();

        virtualinvoke $r4.<java.io.IOException: java.lang.Throwable initCause(java.lang.Throwable)>($r5);

        throw $r4;

     label4:
        return;

        catch java.security.PrivilegedActionException from label1 to label2 with label3;
    }
}
