public abstract class org.apache.commons.compress.archivers.zip.ZipUtil extends java.lang.Object
{
    private static final byte[] DOS_TIME_MIN;

    public void <init>()
    {
        org.apache.commons.compress.archivers.zip.ZipUtil r0;

        r0 := @this: org.apache.commons.compress.archivers.zip.ZipUtil;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        return;
    }

    public static org.apache.commons.compress.archivers.zip.ZipLong toDosTime(java.util.Date)
    {
        byte[] $r2;
        java.util.Date r1;
        org.apache.commons.compress.archivers.zip.ZipLong $r0;
        long $l0;

        r1 := @parameter0: java.util.Date;

        $r0 = new org.apache.commons.compress.archivers.zip.ZipLong;

        $l0 = virtualinvoke r1.<java.util.Date: long getTime()>();

        $r2 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: byte[] toDosTime(long)>($l0);

        specialinvoke $r0.<org.apache.commons.compress.archivers.zip.ZipLong: void <init>(byte[])>($r2);

        return $r0;
    }

    public static byte[] toDosTime(long)
    {
        byte[] $r1, $r2, $r3;
        long l0, l20;
        java.util.Calendar $r0;
        int $i1, $i2, i3, $i4, $i5, $i6, $i7, $i8, $i9, $i10, $i11, $i12, $i13, $i14, $i15, $i16, $i17, $i18, $i19;

        l0 := @parameter0: long;

        $r0 = staticinvoke <java.util.Calendar: java.util.Calendar getInstance()>();

        virtualinvoke $r0.<java.util.Calendar: void setTimeInMillis(long)>(l0);

        $i1 = virtualinvoke $r0.<java.util.Calendar: int get(int)>(1);

        if $i1 >= 1980 goto label1;

        $r2 = <org.apache.commons.compress.archivers.zip.ZipUtil: byte[] DOS_TIME_MIN>;

        $r3 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: byte[] copy(byte[])>($r2);

        return $r3;

     label1:
        $i2 = virtualinvoke $r0.<java.util.Calendar: int get(int)>(2);

        i3 = $i2 + 1;

        $i4 = $i1 - 1980;

        $i6 = $i4 << 25;

        $i5 = i3 << 21;

        $i7 = $i6 | $i5;

        $i8 = virtualinvoke $r0.<java.util.Calendar: int get(int)>(5);

        $i9 = $i8 << 16;

        $i10 = $i7 | $i9;

        $i11 = virtualinvoke $r0.<java.util.Calendar: int get(int)>(11);

        $i12 = $i11 << 11;

        $i13 = $i10 | $i12;

        $i14 = virtualinvoke $r0.<java.util.Calendar: int get(int)>(12);

        $i15 = $i14 << 5;

        $i16 = $i13 | $i15;

        $i17 = virtualinvoke $r0.<java.util.Calendar: int get(int)>(13);

        $i18 = $i17 >> 1;

        $i19 = $i16 | $i18;

        l20 = (long) $i19;

        $r1 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipLong: byte[] getBytes(long)>(l20);

        return $r1;
    }

    public static long adjustToLong(int)
    {
        int i0;
        long $l1, $l2, $l3;

        i0 := @parameter0: int;

        if i0 >= 0 goto label1;

        $l2 = (long) i0;

        $l3 = 4294967296L + $l2;

        return $l3;

     label1:
        $l1 = (long) i0;

        return $l1;
    }

    public static byte[] reverse(byte[])
    {
        byte[] r0;
        byte b4, $b6;
        int $i0, i1, $i2, $i3, $i5, $i7, i8;

        r0 := @parameter0: byte[];

        $i0 = lengthof r0;

        i1 = $i0 - 1;

        i8 = 0;

     label1:
        $i2 = lengthof r0;

        $i3 = $i2 / 2;

        if i8 >= $i3 goto label2;

        b4 = r0[i8];

        $i5 = i1 - i8;

        $b6 = r0[$i5];

        r0[i8] = $b6;

        $i7 = i1 - i8;

        r0[$i7] = b4;

        i8 = i8 + 1;

        goto label1;

     label2:
        return r0;
    }

    static long bigToLong(java.math.BigInteger)
    {
        java.lang.NumberFormatException $r1;
        long $l1;
        int $i0;
        java.math.BigInteger r0;
        java.lang.StringBuilder $r2, $r3, $r4, $r5;
        java.lang.String $r6;

        r0 := @parameter0: java.math.BigInteger;

        $i0 = virtualinvoke r0.<java.math.BigInteger: int bitLength()>();

        if $i0 > 63 goto label1;

        $l1 = virtualinvoke r0.<java.math.BigInteger: long longValue()>();

        return $l1;

     label1:
        $r1 = new java.lang.NumberFormatException;

        $r2 = new java.lang.StringBuilder;

        specialinvoke $r2.<java.lang.StringBuilder: void <init>()>();

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("The BigInteger cannot fit inside a 64 bit java long: [");

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("]");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r1.<java.lang.NumberFormatException: void <init>(java.lang.String)>($r6);

        throw $r1;
    }

    static java.math.BigInteger longToBig(long)
    {
        long l4;
        java.lang.IllegalArgumentException $r8;
        byte $b0, $b1, $b2;
        int $i3, $i5, $i6, $i7;
        java.lang.StringBuilder $r2, $r3, $r4, $r7;
        java.math.BigInteger $r6;
        java.lang.String $r5;

        l4 := @parameter0: long;

        $b0 = l4 cmp -2147483648L;

        $i5 = (int) $b0;

        if $i5 >= 0 goto label1;

        $r8 = new java.lang.IllegalArgumentException;

        $r7 = new java.lang.StringBuilder;

        specialinvoke $r7.<java.lang.StringBuilder: void <init>()>();

        $r2 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Negative longs < -2^31 not permitted: [");

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(long)>(l4);

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("]");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r8.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r5);

        throw $r8;

     label1:
        $b1 = l4 cmp 0L;

        $i6 = (int) $b1;

        if $i6 >= 0 goto label2;

        $b2 = l4 cmp -2147483648L;

        $i7 = (int) $b2;

        if $i7 < 0 goto label2;

        $i3 = (int) l4;

        l4 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: long adjustToLong(int)>($i3);

     label2:
        $r6 = staticinvoke <java.math.BigInteger: java.math.BigInteger valueOf(long)>(l4);

        return $r6;
    }

    public static int signedByteToUnsignedInt(byte)
    {
        byte b0;
        int $i1, $i2, $i3, $i4;

        b0 := @parameter0: byte;

        $i2 = (int) b0;

        if $i2 < 0 goto label1;

        $i3 = (int) b0;

        return $i3;

     label1:
        $i4 = (int) b0;

        $i1 = 256 + $i4;

        return $i1;
    }

    public static byte unsignedIntToSignedByte(int)
    {
        java.lang.IllegalArgumentException $r0;
        byte $b2, $b3;
        int i0, $i1;
        java.lang.StringBuilder $r1, $r2, $r3, $r4;
        java.lang.String $r5;

        i0 := @parameter0: int;

        if i0 > 255 goto label1;

        if i0 >= 0 goto label2;

     label1:
        $r0 = new java.lang.IllegalArgumentException;

        $r1 = new java.lang.StringBuilder;

        specialinvoke $r1.<java.lang.StringBuilder: void <init>()>();

        $r2 = virtualinvoke $r1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Can only convert non-negative integers between [0,255] to byte: [");

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i0);

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("]");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r0.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r5);

        throw $r0;

     label2:
        if i0 >= 128 goto label3;

        $b3 = (byte) i0;

        return $b3;

     label3:
        $i1 = i0 - 256;

        $b2 = (byte) $i1;

        return $b2;
    }

    public static java.util.Date fromDosTime(org.apache.commons.compress.archivers.zip.ZipLong)
    {
        java.util.Date $r1;
        org.apache.commons.compress.archivers.zip.ZipLong r0;
        long $l0, $l1;

        r0 := @parameter0: org.apache.commons.compress.archivers.zip.ZipLong;

        $l0 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipLong: long getValue()>();

        $r1 = new java.util.Date;

        $l1 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: long dosToJavaTime(long)>($l0);

        specialinvoke $r1.<java.util.Date: void <init>(long)>($l1);

        return $r1;
    }

    public static long dosToJavaTime(long)
    {
        java.util.Date $r1;
        long l0, $l1, $l2, $l5, $l6, $l9, $l12, $l15, $l18, $l21;
        java.util.Calendar $r0;
        int $i3, $i4, $i7, $i8, $i10, $i11, $i13, $i14, $i16, $i17, $i19, $i20;

        l0 := @parameter0: long;

        $r0 = staticinvoke <java.util.Calendar: java.util.Calendar getInstance()>();

        $l1 = l0 >> 25;

        $l2 = $l1 & 127L;

        $i3 = (int) $l2;

        $i4 = $i3 + 1980;

        virtualinvoke $r0.<java.util.Calendar: void set(int,int)>(1, $i4);

        $l5 = l0 >> 21;

        $l6 = $l5 & 15L;

        $i7 = (int) $l6;

        $i8 = $i7 - 1;

        virtualinvoke $r0.<java.util.Calendar: void set(int,int)>(2, $i8);

        $l9 = l0 >> 16;

        $i10 = (int) $l9;

        $i11 = $i10 & 31;

        virtualinvoke $r0.<java.util.Calendar: void set(int,int)>(5, $i11);

        $l12 = l0 >> 11;

        $i13 = (int) $l12;

        $i14 = $i13 & 31;

        virtualinvoke $r0.<java.util.Calendar: void set(int,int)>(11, $i14);

        $l15 = l0 >> 5;

        $i16 = (int) $l15;

        $i17 = $i16 & 63;

        virtualinvoke $r0.<java.util.Calendar: void set(int,int)>(12, $i17);

        $l18 = l0 << 1;

        $i19 = (int) $l18;

        $i20 = $i19 & 62;

        virtualinvoke $r0.<java.util.Calendar: void set(int,int)>(13, $i20);

        virtualinvoke $r0.<java.util.Calendar: void set(int,int)>(14, 0);

        $r1 = virtualinvoke $r0.<java.util.Calendar: java.util.Date getTime()>();

        $l21 = virtualinvoke $r1.<java.util.Date: long getTime()>();

        return $l21;
    }

    static void setNameAndCommentFromExtraFields(org.apache.commons.compress.archivers.zip.ZipArchiveEntry, byte[], byte[])
    {
        byte[] r5, r7;
        org.apache.commons.compress.archivers.zip.ZipArchiveEntry r0;
        org.apache.commons.compress.archivers.zip.UnicodePathExtraField r3;
        org.apache.commons.compress.archivers.zip.ZipExtraField $r2, $r9;
        org.apache.commons.compress.archivers.zip.ZipShort $r1, $r8;
        int $i0;
        java.lang.String $r4, $r6, $r11;
        org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField r10;
        boolean $z0;

        r0 := @parameter0: org.apache.commons.compress.archivers.zip.ZipArchiveEntry;

        r5 := @parameter1: byte[];

        r7 := @parameter2: byte[];

        $r1 = <org.apache.commons.compress.archivers.zip.UnicodePathExtraField: org.apache.commons.compress.archivers.zip.ZipShort UPATH_ID>;

        $r2 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: org.apache.commons.compress.archivers.zip.ZipExtraField getExtraField(org.apache.commons.compress.archivers.zip.ZipShort)>($r1);

        r3 = (org.apache.commons.compress.archivers.zip.UnicodePathExtraField) $r2;

        $r4 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: java.lang.String getName()>();

        $r6 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: java.lang.String getUnicodeStringIfOriginalMatches(org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField,byte[])>(r3, r5);

        if $r6 == null goto label1;

        $z0 = virtualinvoke $r4.<java.lang.String: boolean equals(java.lang.Object)>($r6);

        if $z0 != 0 goto label1;

        virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: void setName(java.lang.String)>($r6);

     label1:
        if r7 == null goto label2;

        $i0 = lengthof r7;

        if $i0 <= 0 goto label2;

        $r8 = <org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField: org.apache.commons.compress.archivers.zip.ZipShort UCOM_ID>;

        $r9 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: org.apache.commons.compress.archivers.zip.ZipExtraField getExtraField(org.apache.commons.compress.archivers.zip.ZipShort)>($r8);

        r10 = (org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField) $r9;

        $r11 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: java.lang.String getUnicodeStringIfOriginalMatches(org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField,byte[])>(r10, r7);

        if $r11 == null goto label2;

        virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: void setComment(java.lang.String)>($r11);

     label2:
        return;
    }

    private static java.lang.String getUnicodeStringIfOriginalMatches(org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField, byte[])
    {
        byte[] r2, $r4;
        org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField r0;
        long $l0, $l1;
        java.io.IOException $r6;
        org.apache.commons.compress.archivers.zip.ZipEncoding $r3;
        byte $b2;
        java.util.zip.CRC32 $r1;
        java.lang.String $r5;

        r0 := @parameter0: org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField;

        r2 := @parameter1: byte[];

        if r0 == null goto label4;

        $r1 = new java.util.zip.CRC32;

        specialinvoke $r1.<java.util.zip.CRC32: void <init>()>();

        virtualinvoke $r1.<java.util.zip.CRC32: void update(byte[])>(r2);

        $l0 = virtualinvoke $r1.<java.util.zip.CRC32: long getValue()>();

        $l1 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField: long getNameCRC32()>();

        $b2 = $l0 cmp $l1;

        if $b2 != 0 goto label4;

     label1:
        $r3 = <org.apache.commons.compress.archivers.zip.ZipEncodingHelper: org.apache.commons.compress.archivers.zip.ZipEncoding UTF8_ZIP_ENCODING>;

        $r4 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField: byte[] getUnicodeName()>();

        $r5 = interfaceinvoke $r3.<org.apache.commons.compress.archivers.zip.ZipEncoding: java.lang.String decode(byte[])>($r4);

     label2:
        return $r5;

     label3:
        $r6 := @caughtexception;

        return null;

     label4:
        return null;

        catch java.io.IOException from label1 to label2 with label3;
    }

    static byte[] copy(byte[])
    {
        byte[] r0, r1;
        int $i0, $i1;

        r0 := @parameter0: byte[];

        if r0 == null goto label1;

        $i0 = lengthof r0;

        r1 = newarray (byte)[$i0];

        $i1 = lengthof r1;

        staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(r0, 0, r1, 0, $i1);

        return r1;

     label1:
        return null;
    }

    static boolean canHandleEntryData(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)
    {
        org.apache.commons.compress.archivers.zip.ZipArchiveEntry r0;
        boolean $z0, $z1, $z2;

        r0 := @parameter0: org.apache.commons.compress.archivers.zip.ZipArchiveEntry;

        $z0 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: boolean supportsEncryptionOf(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)>(r0);

        if $z0 == 0 goto label1;

        $z1 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: boolean supportsMethodOf(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)>(r0);

        if $z1 == 0 goto label1;

        $z2 = 1;

        goto label2;

     label1:
        $z2 = 0;

     label2:
        return $z2;
    }

    private static boolean supportsEncryptionOf(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)
    {
        org.apache.commons.compress.archivers.zip.ZipArchiveEntry r0;
        org.apache.commons.compress.archivers.zip.GeneralPurposeBit $r1;
        boolean $z0, $z1;

        r0 := @parameter0: org.apache.commons.compress.archivers.zip.ZipArchiveEntry;

        $r1 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: org.apache.commons.compress.archivers.zip.GeneralPurposeBit getGeneralPurposeBit()>();

        $z0 = virtualinvoke $r1.<org.apache.commons.compress.archivers.zip.GeneralPurposeBit: boolean usesEncryption()>();

        if $z0 != 0 goto label1;

        $z1 = 1;

        goto label2;

     label1:
        $z1 = 0;

     label2:
        return $z1;
    }

    private static boolean supportsMethodOf(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)
    {
        org.apache.commons.compress.archivers.zip.ZipArchiveEntry r0;
        org.apache.commons.compress.archivers.zip.ZipMethod $r1, $r2;
        int $i0, $i1, $i2, $i3, $i4, $i5;
        boolean $z0;

        r0 := @parameter0: org.apache.commons.compress.archivers.zip.ZipArchiveEntry;

        $i0 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: int getMethod()>();

        if $i0 == 0 goto label1;

        $i1 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: int getMethod()>();

        $r1 = <org.apache.commons.compress.archivers.zip.ZipMethod: org.apache.commons.compress.archivers.zip.ZipMethod UNSHRINKING>;

        $i2 = virtualinvoke $r1.<org.apache.commons.compress.archivers.zip.ZipMethod: int getCode()>();

        if $i1 == $i2 goto label1;

        $i3 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: int getMethod()>();

        $r2 = <org.apache.commons.compress.archivers.zip.ZipMethod: org.apache.commons.compress.archivers.zip.ZipMethod IMPLODING>;

        $i4 = virtualinvoke $r2.<org.apache.commons.compress.archivers.zip.ZipMethod: int getCode()>();

        if $i3 == $i4 goto label1;

        $i5 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: int getMethod()>();

        if $i5 != 8 goto label2;

     label1:
        $z0 = 1;

        goto label3;

     label2:
        $z0 = 0;

     label3:
        return $z0;
    }

    static void checkRequestedFeatures(org.apache.commons.compress.archivers.zip.ZipArchiveEntry) throws org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException
    {
        org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException$Feature $r4, $r6;
        org.apache.commons.compress.archivers.zip.ZipArchiveEntry r0;
        org.apache.commons.compress.archivers.zip.ZipMethod $r1;
        int $i0;
        org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException $r2, $r3, $r5;
        boolean $z0, $z1;

        r0 := @parameter0: org.apache.commons.compress.archivers.zip.ZipArchiveEntry;

        $z0 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: boolean supportsEncryptionOf(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)>(r0);

        if $z0 != 0 goto label1;

        $r5 = new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException;

        $r6 = <org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException$Feature: org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException$Feature ENCRYPTION>;

        specialinvoke $r5.<org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException: void <init>(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException$Feature,org.apache.commons.compress.archivers.zip.ZipArchiveEntry)>($r6, r0);

        throw $r5;

     label1:
        $z1 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipUtil: boolean supportsMethodOf(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)>(r0);

        if $z1 != 0 goto label3;

        $i0 = virtualinvoke r0.<org.apache.commons.compress.archivers.zip.ZipArchiveEntry: int getMethod()>();

        $r1 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipMethod: org.apache.commons.compress.archivers.zip.ZipMethod getMethodByCode(int)>($i0);

        if $r1 != null goto label2;

        $r3 = new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException;

        $r4 = <org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException$Feature: org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException$Feature METHOD>;

        specialinvoke $r3.<org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException: void <init>(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException$Feature,org.apache.commons.compress.archivers.zip.ZipArchiveEntry)>($r4, r0);

        throw $r3;

     label2:
        $r2 = new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException;

        specialinvoke $r2.<org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException: void <init>(org.apache.commons.compress.archivers.zip.ZipMethod,org.apache.commons.compress.archivers.zip.ZipArchiveEntry)>($r1, r0);

        throw $r2;

     label3:
        return;
    }

    static void <clinit>()
    {
        byte[] $r0;

        $r0 = staticinvoke <org.apache.commons.compress.archivers.zip.ZipLong: byte[] getBytes(long)>(8448L);

        <org.apache.commons.compress.archivers.zip.ZipUtil: byte[] DOS_TIME_MIN> = $r0;

        return;
    }
}
