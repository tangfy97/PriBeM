public final class minsolver.MinSolver extends java.lang.Object
{
    private final kodkod.engine.config.Options options;
    private final minsolver.MinExtraOptions extraOptions;
    private minsolver.MinSolver$MinSolutionIterator activeIterator;

    public void <init>()
    {
        kodkod.engine.config.Options $r1;
        minsolver.MinSolver r0;
        minsolver.MinExtraOptions $r2;

        r0 := @this: minsolver.MinSolver;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        $r1 = new kodkod.engine.config.Options;

        specialinvoke $r1.<kodkod.engine.config.Options: void <init>()>();

        r0.<minsolver.MinSolver: kodkod.engine.config.Options options> = $r1;

        $r2 = new minsolver.MinExtraOptions;

        specialinvoke $r2.<minsolver.MinExtraOptions: void <init>()>();

        r0.<minsolver.MinSolver: minsolver.MinExtraOptions extraOptions> = $r2;

        return;
    }

    public void <init>(kodkod.engine.config.Options)
    {
        kodkod.engine.config.Options r1;
        minsolver.MinSolver r0;
        minsolver.MinExtraOptions $r2;
        java.lang.NullPointerException $r3;

        r0 := @this: minsolver.MinSolver;

        r1 := @parameter0: kodkod.engine.config.Options;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        if r1 != null goto label1;

        $r3 = new java.lang.NullPointerException;

        specialinvoke $r3.<java.lang.NullPointerException: void <init>()>();

        throw $r3;

     label1:
        r0.<minsolver.MinSolver: kodkod.engine.config.Options options> = r1;

        $r2 = new minsolver.MinExtraOptions;

        specialinvoke $r2.<minsolver.MinExtraOptions: void <init>()>();

        r0.<minsolver.MinSolver: minsolver.MinExtraOptions extraOptions> = $r2;

        return;
    }

    public void <init>(kodkod.engine.config.Options, minsolver.MinExtraOptions)
    {
        kodkod.engine.config.Options r1;
        minsolver.MinSolver r0;
        minsolver.MinExtraOptions r3;
        java.lang.NullPointerException $r2;

        r0 := @this: minsolver.MinSolver;

        r1 := @parameter0: kodkod.engine.config.Options;

        r3 := @parameter1: minsolver.MinExtraOptions;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        if r1 == null goto label1;

        if r3 != null goto label2;

     label1:
        $r2 = new java.lang.NullPointerException;

        specialinvoke $r2.<java.lang.NullPointerException: void <init>()>();

        throw $r2;

     label2:
        r0.<minsolver.MinSolver: kodkod.engine.config.Options options> = r1;

        r0.<minsolver.MinSolver: minsolver.MinExtraOptions extraOptions> = r3;

        return;
    }

    public kodkod.engine.config.Options options()
    {
        kodkod.engine.config.Options $r1;
        minsolver.MinSolver r0;

        r0 := @this: minsolver.MinSolver;

        $r1 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        return $r1;
    }

    public minsolver.MinExtraOptions extraOptions()
    {
        minsolver.MinSolver r0;
        minsolver.MinExtraOptions $r1;

        r0 := @this: minsolver.MinSolver;

        $r1 = r0.<minsolver.MinSolver: minsolver.MinExtraOptions extraOptions>;

        return $r1;
    }

    public minsolver.MinSolution solve(kodkod.ast.Formula, kodkod.instance.Bounds) throws minsolver.fol2sat.MinHigherOrderDeclException, minsolver.fol2sat.MinUnboundLeafException, minsolver.MinAbortedException
    {
        kodkod.engine.config.Options $r3, $r6;
        long $l0, $l1, $l5, $l6, $l7, $l8, $l9, $l10;
        minsolver.fol2sat.MinTranslation $r4;
        kodkod.instance.Bounds r1;
        int $i2, $i3, $i4;
        minsolver.MinSATSolver $r5;
        minsolver.MinStatistics $r8;
        boolean $z0;
        minsolver.MinAbortedException $r10;
        minsolver.fol2sat.MinTrivialFormulaException $r11;
        kodkod.ast.Formula r0;
        kodkod.engine.config.Reporter $r7;
        kodkod.engine.satlab.SATAbortedException $r9;
        minsolver.MinSolver r2;
        minsolver.MinSolution $r12, $r13;

        r2 := @this: minsolver.MinSolver;

        r0 := @parameter0: kodkod.ast.Formula;

        r1 := @parameter1: kodkod.instance.Bounds;

        $l0 = staticinvoke <java.lang.System: long currentTimeMillis()>();

     label1:
        $r3 = r2.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r4 = staticinvoke <minsolver.fol2sat.MinTranslator: minsolver.fol2sat.MinTranslation translate(kodkod.ast.Formula,kodkod.instance.Bounds,kodkod.engine.config.Options)>(r0, r1, $r3);

        $l1 = staticinvoke <java.lang.System: long currentTimeMillis()>();

        $r5 = virtualinvoke $r4.<minsolver.fol2sat.MinTranslation: minsolver.MinSATSolver cnf()>();

        $r6 = r2.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r7 = virtualinvoke $r6.<kodkod.engine.config.Options: kodkod.engine.config.Reporter reporter()>();

        $i2 = virtualinvoke $r4.<minsolver.fol2sat.MinTranslation: int numPrimaryVariables()>();

        $i3 = interfaceinvoke $r5.<kodkod.engine.satlab.SATSolver: int numberOfVariables()>();

        $i4 = interfaceinvoke $r5.<kodkod.engine.satlab.SATSolver: int numberOfClauses()>();

        interfaceinvoke $r7.<kodkod.engine.config.Reporter: void solvingCNF(int,int,int)>($i2, $i3, $i4);

        $l5 = staticinvoke <java.lang.System: long currentTimeMillis()>();

        $z0 = interfaceinvoke $r5.<kodkod.engine.satlab.SATSolver: boolean solve()>();

        $l6 = staticinvoke <java.lang.System: long currentTimeMillis()>();

        $r8 = new minsolver.MinStatistics;

        $l8 = $l1 - $l0;

        $l7 = $l6 - $l5;

        specialinvoke $r8.<minsolver.MinStatistics: void <init>(minsolver.fol2sat.MinTranslation,long,long)>($r4, $l8, $l7);

        if $z0 == 0 goto label2;

        $r13 = staticinvoke <minsolver.MinSolver: minsolver.MinSolution sat(kodkod.instance.Bounds,minsolver.fol2sat.MinTranslation,minsolver.MinStatistics)>(r1, $r4, $r8);

        goto label3;

     label2:
        $r13 = staticinvoke <minsolver.MinSolver: minsolver.MinSolution unsat(minsolver.fol2sat.MinTranslation,minsolver.MinStatistics)>($r4, $r8);

     label3:
        return $r13;

     label4:
        $r11 := @caughtexception;

        $l9 = staticinvoke <java.lang.System: long currentTimeMillis()>();

        $l10 = $l9 - $l0;

        $r12 = staticinvoke <minsolver.MinSolver: minsolver.MinSolution trivial(kodkod.instance.Bounds,minsolver.fol2sat.MinTrivialFormulaException,long)>(r1, $r11, $l10);

        return $r12;

     label5:
        $r9 := @caughtexception;

        $r10 = new minsolver.MinAbortedException;

        specialinvoke $r10.<minsolver.MinAbortedException: void <init>(java.lang.Throwable)>($r9);

        throw $r10;

        catch minsolver.fol2sat.MinTrivialFormulaException from label1 to label3 with label4;
        catch kodkod.engine.satlab.SATAbortedException from label1 to label3 with label5;
    }

    public java.util.Iterator solveAll(kodkod.ast.Formula, kodkod.instance.Bounds) throws minsolver.fol2sat.MinHigherOrderDeclException, minsolver.fol2sat.MinUnboundLeafException, minsolver.MinAbortedException
    {
        kodkod.engine.config.Options $r1, $r7;
        kodkod.engine.satlab.SATFactory $r2;
        minsolver.MinSolver$MinSolutionIterator $r3;
        kodkod.ast.Formula r4;
        java.lang.IllegalArgumentException $r8;
        minsolver.MinSolver r0;
        kodkod.instance.Bounds r5;
        minsolver.MinExtraOptions $r6;
        boolean $z0;

        r0 := @this: minsolver.MinSolver;

        r4 := @parameter0: kodkod.ast.Formula;

        r5 := @parameter1: kodkod.instance.Bounds;

        $r1 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r2 = virtualinvoke $r1.<kodkod.engine.config.Options: kodkod.engine.satlab.SATFactory solver()>();

        $z0 = virtualinvoke $r2.<kodkod.engine.satlab.SATFactory: boolean incremental()>();

        if $z0 != 0 goto label1;

        $r8 = new java.lang.IllegalArgumentException;

        specialinvoke $r8.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("cannot enumerate solutions without an incremental solver.");

        throw $r8;

     label1:
        $r3 = new minsolver.MinSolver$MinSolutionIterator;

        $r7 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r6 = r0.<minsolver.MinSolver: minsolver.MinExtraOptions extraOptions>;

        specialinvoke $r3.<minsolver.MinSolver$MinSolutionIterator: void <init>(minsolver.MinSolver,kodkod.ast.Formula,kodkod.instance.Bounds,kodkod.engine.config.Options,minsolver.MinExtraOptions)>(r0, r4, r5, $r7, $r6);

        return $r3;
    }

    public minsolver.MinSolver$MinSolutionIterator lift(kodkod.ast.Formula, java.util.Iterator, kodkod.instance.Instance) throws minsolver.fol2sat.MinHigherOrderDeclException, minsolver.fol2sat.MinUnboundLeafException, minsolver.MinAbortedException, minsolver.ExplorationException
    {
        minsolver.MinSolver$MinSolutionIterator r4, $r56;
        minsolver.fol2sat.MinTranslation $r21, $r31;
        java.lang.Integer $r22, $r32;
        kodkod.instance.Bounds $r42;
        java.util.Map $r12, $r14;
        boolean $z0, $z1, $z2, $z3, $z4, $z5, $z6, $z7;
        kodkod.engine.satlab.SATFactory $r2;
        kodkod.engine.config.Reporter $r7;
        java.util.Set $r15, $r23;
        minsolver.MinSolution $r5, $r10;
        java.lang.StringBuilder $r35, $r36, $r54;
        kodkod.ast.Relation r45, r48;
        kodkod.engine.config.Options $r1, $r6, $r41;
        java.util.ArrayList $r53;
        kodkod.instance.Instance $r11, r13;
        minsolver.ExplorationException $r52, $r55;
        int $i0, $i1, $i3, $i5;
        java.lang.String $r37;
        kodkod.instance.TupleSet $r30, r46, r49;
        kodkod.instance.Tuple r47, r50;
        java.util.Iterator r3, $r16, $r19, $r24, $r27;
        kodkod.ast.Formula r39;
        java.lang.IllegalArgumentException $r51;
        minsolver.MinSolver r0;
        minsolver.MyReporter $r8;
        java.lang.Object $r17, $r18, $r20, $r25, $r26, $r28, $r29;
        minsolver.MinExtraOptions $r40;

        r0 := @this: minsolver.MinSolver;

        r39 := @parameter0: kodkod.ast.Formula;

        r3 := @parameter1: java.util.Iterator;

        r13 := @parameter2: kodkod.instance.Instance;

        $r1 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r2 = virtualinvoke $r1.<kodkod.engine.config.Options: kodkod.engine.satlab.SATFactory solver()>();

        $z0 = virtualinvoke $r2.<kodkod.engine.satlab.SATFactory: boolean incremental()>();

        if $z0 != 0 goto label01;

        $r51 = new java.lang.IllegalArgumentException;

        specialinvoke $r51.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("cannot enumerate solutions without an incremental solver.");

        throw $r51;

     label01:
        r4 = (minsolver.MinSolver$MinSolutionIterator) r3;

        $z1 = staticinvoke <minsolver.MinSolver$MinSolutionIterator: boolean access$1(minsolver.MinSolver$MinSolutionIterator)>(r4);

        if $z1 == 0 goto label02;

        staticinvoke <javax.swing.JOptionPane: void showMessageDialog(java.awt.Component,java.lang.Object)>(null, "The spec given was trivially satisfiable, and so it had only one minimal model (shown),\nto which any relational fact in the set of consistent facts may be added without consequence.\n\nExplicit exploration is unavailable.");

        return r4;

     label02:
        $r5 = r4.<minsolver.MinSolver$MinSolutionIterator: minsolver.MinSolution lastSatSolutionFound>;

        if $r5 != null goto label03;

        $z4 = virtualinvoke r4.<minsolver.MinSolver$MinSolutionIterator: boolean hasNext()>();

        if $z4 != 0 goto label03;

        $r52 = new minsolver.ExplorationException;

        specialinvoke $r52.<minsolver.ExplorationException: void <init>(java.lang.String)>("Attempted to augment without a model.");

        throw $r52;

     label03:
        $r6 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r7 = virtualinvoke $r6.<kodkod.engine.config.Options: kodkod.engine.config.Reporter reporter()>();

        $r8 = (minsolver.MyReporter) $r7;

        $r42 = $r8.<minsolver.MyReporter: kodkod.instance.Bounds skolemBounds>;

        $r53 = new java.util.ArrayList;

        specialinvoke $r53.<java.util.ArrayList: void <init>()>();

        $r10 = r4.<minsolver.MinSolver$MinSolutionIterator: minsolver.MinSolution lastSatSolutionFound>;

        $r11 = virtualinvoke $r10.<minsolver.MinSolution: kodkod.instance.Instance instance()>();

        $r12 = virtualinvoke $r11.<kodkod.instance.Instance: java.util.Map relationTuples()>();

        $r14 = virtualinvoke r13.<kodkod.instance.Instance: java.util.Map relationTuples()>();

        $r15 = interfaceinvoke $r12.<java.util.Map: java.util.Set keySet()>();

        $r16 = interfaceinvoke $r15.<java.util.Set: java.util.Iterator iterator()>();

        goto label08;

     label04:
        $r17 = interfaceinvoke $r16.<java.util.Iterator: java.lang.Object next()>();

        r45 = (kodkod.ast.Relation) $r17;

        $r18 = interfaceinvoke $r12.<java.util.Map: java.lang.Object get(java.lang.Object)>(r45);

        r46 = (kodkod.instance.TupleSet) $r18;

        $r19 = virtualinvoke r46.<kodkod.instance.TupleSet: java.util.Iterator iterator()>();

        goto label07;

     label05:
        $r20 = interfaceinvoke $r19.<java.util.Iterator: java.lang.Object next()>();

        r47 = (kodkod.instance.Tuple) $r20;

        $r21 = virtualinvoke r4.<minsolver.MinSolver$MinSolutionIterator: minsolver.fol2sat.MinTranslation getTranslation()>();

        $i0 = staticinvoke <minsolver.MinSolver$MinTwoWayTranslator: int access$2(kodkod.instance.Bounds,minsolver.fol2sat.MinTranslation,kodkod.ast.Relation,kodkod.instance.Tuple)>($r42, $r21, r45, r47);

        $i3 = (int) -1;

        if $i0 != $i3 goto label06;

        goto label07;

     label06:
        $r22 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(int)>($i0);

        virtualinvoke $r53.<java.util.ArrayList: boolean add(java.lang.Object)>($r22);

     label07:
        $z5 = interfaceinvoke $r19.<java.util.Iterator: boolean hasNext()>();

        if $z5 != 0 goto label05;

     label08:
        $z2 = interfaceinvoke $r16.<java.util.Iterator: boolean hasNext()>();

        if $z2 != 0 goto label04;

        $r23 = interfaceinvoke $r14.<java.util.Map: java.util.Set keySet()>();

        $r24 = interfaceinvoke $r23.<java.util.Set: java.util.Iterator iterator()>();

        goto label14;

     label09:
        $r25 = interfaceinvoke $r24.<java.util.Iterator: java.lang.Object next()>();

        r48 = (kodkod.ast.Relation) $r25;

        $r26 = interfaceinvoke $r14.<java.util.Map: java.lang.Object get(java.lang.Object)>(r48);

        r49 = (kodkod.instance.TupleSet) $r26;

        if r49 == null goto label14;

        $r27 = virtualinvoke r49.<kodkod.instance.TupleSet: java.util.Iterator iterator()>();

        goto label13;

     label10:
        $r28 = interfaceinvoke $r27.<java.util.Iterator: java.lang.Object next()>();

        r50 = (kodkod.instance.Tuple) $r28;

        $r29 = interfaceinvoke $r12.<java.util.Map: java.lang.Object get(java.lang.Object)>(r48);

        $r30 = (kodkod.instance.TupleSet) $r29;

        $z3 = virtualinvoke $r30.<kodkod.instance.TupleSet: boolean contains(java.lang.Object)>(r50);

        if $z3 == 0 goto label11;

        $r55 = new minsolver.ExplorationException;

        $r54 = new java.lang.StringBuilder;

        specialinvoke $r54.<java.lang.StringBuilder: void <init>(java.lang.String)>("The fact ");

        $r35 = virtualinvoke $r54.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r50);

        $r36 = virtualinvoke $r35.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" is already true in the solution.");

        $r37 = virtualinvoke $r36.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r55.<minsolver.ExplorationException: void <init>(java.lang.String)>($r37);

        throw $r55;

     label11:
        $r31 = virtualinvoke r4.<minsolver.MinSolver$MinSolutionIterator: minsolver.fol2sat.MinTranslation getTranslation()>();

        $i1 = staticinvoke <minsolver.MinSolver$MinTwoWayTranslator: int access$2(kodkod.instance.Bounds,minsolver.fol2sat.MinTranslation,kodkod.ast.Relation,kodkod.instance.Tuple)>($r42, $r31, r48, r50);

        $i5 = (int) -1;

        if $i1 != $i5 goto label12;

        goto label13;

     label12:
        $r32 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(int)>($i1);

        virtualinvoke $r53.<java.util.ArrayList: boolean add(java.lang.Object)>($r32);

     label13:
        $z6 = interfaceinvoke $r27.<java.util.Iterator: boolean hasNext()>();

        if $z6 != 0 goto label10;

     label14:
        $z7 = interfaceinvoke $r24.<java.util.Iterator: boolean hasNext()>();

        if $z7 != 0 goto label09;

        $r56 = new minsolver.MinSolver$MinSolutionIterator;

        $r41 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r40 = r0.<minsolver.MinSolver: minsolver.MinExtraOptions extraOptions>;

        specialinvoke $r56.<minsolver.MinSolver$MinSolutionIterator: void <init>(minsolver.MinSolver,kodkod.ast.Formula,kodkod.instance.Bounds,kodkod.engine.config.Options,minsolver.MinExtraOptions,java.util.ArrayList,minsolver.MinSolver$MinSolutionIterator)>(r0, r39, $r42, $r41, $r40, $r53, r4);

        return $r56;
    }

    public kodkod.instance.Instance getLifters(java.util.Iterator) throws org.sat4j.specs.TimeoutException, org.sat4j.specs.ContradictionException
    {
        kodkod.engine.config.Options $r3, $r11;
        minsolver.MinSolver$MinSolutionIterator r1;
        minsolver.fol2sat.MinTranslation $r2;
        kodkod.instance.Instance $r9, $r15;
        kodkod.instance.Bounds $r6, r14;
        int[] $r8;
        java.util.Map $r7;
        kodkod.instance.Universe $r16;
        boolean $z0, $z1;
        kodkod.instance.TupleSet $r21, $r22, $r23;
        java.util.Iterator r0, $r18;
        kodkod.engine.config.Reporter $r4, $r12;
        java.util.Set $r17;
        minsolver.MinSolver r10;
        minsolver.MyReporter $r5, $r13;
        java.lang.Object $r19;
        kodkod.ast.Relation r20;

        r10 := @this: minsolver.MinSolver;

        r0 := @parameter0: java.util.Iterator;

        r1 = (minsolver.MinSolver$MinSolutionIterator) r0;

        $z0 = staticinvoke <minsolver.MinSolver$MinSolutionIterator: boolean access$1(minsolver.MinSolver$MinSolutionIterator)>(r1);

        if $z0 == 0 goto label3;

        $r11 = r10.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r12 = virtualinvoke $r11.<kodkod.engine.config.Options: kodkod.engine.config.Reporter reporter()>();

        $r13 = (minsolver.MyReporter) $r12;

        r14 = $r13.<minsolver.MyReporter: kodkod.instance.Bounds skolemBounds>;

        $r15 = new kodkod.instance.Instance;

        $r16 = virtualinvoke r14.<kodkod.instance.Bounds: kodkod.instance.Universe universe()>();

        specialinvoke $r15.<kodkod.instance.Instance: void <init>(kodkod.instance.Universe)>($r16);

        $r17 = virtualinvoke r14.<kodkod.instance.Bounds: java.util.Set relations()>();

        $r18 = interfaceinvoke $r17.<java.util.Set: java.util.Iterator iterator()>();

        goto label2;

     label1:
        $r19 = interfaceinvoke $r18.<java.util.Iterator: java.lang.Object next()>();

        r20 = (kodkod.ast.Relation) $r19;

        $r21 = virtualinvoke r14.<kodkod.instance.Bounds: kodkod.instance.TupleSet upperBound(kodkod.ast.Relation)>(r20);

        $r22 = virtualinvoke $r21.<kodkod.instance.TupleSet: kodkod.instance.TupleSet clone()>();

        $r23 = virtualinvoke r14.<kodkod.instance.Bounds: kodkod.instance.TupleSet lowerBound(kodkod.ast.Relation)>(r20);

        virtualinvoke $r22.<kodkod.instance.TupleSet: boolean removeAll(java.util.Collection)>($r23);

        virtualinvoke $r15.<kodkod.instance.Instance: void add(kodkod.ast.Relation,kodkod.instance.TupleSet)>(r20, $r22);

     label2:
        $z1 = interfaceinvoke $r18.<java.util.Iterator: boolean hasNext()>();

        if $z1 != 0 goto label1;

        return $r15;

     label3:
        $r2 = staticinvoke <minsolver.MinSolver$MinSolutionIterator: minsolver.fol2sat.MinTranslation access$2(minsolver.MinSolver$MinSolutionIterator)>(r1);

        $r3 = staticinvoke <minsolver.MinSolver$MinSolutionIterator: kodkod.engine.config.Options access$3(minsolver.MinSolver$MinSolutionIterator)>(r1);

        $r4 = virtualinvoke $r3.<kodkod.engine.config.Options: kodkod.engine.config.Reporter reporter()>();

        $r5 = (minsolver.MyReporter) $r4;

        $r6 = $r5.<minsolver.MyReporter: kodkod.instance.Bounds skolemBounds>;

        $r7 = staticinvoke <minsolver.MinSolver$MinSolutionIterator: java.util.Map access$4(minsolver.MinSolver$MinSolutionIterator)>(r1);

        $r8 = virtualinvoke r1.<minsolver.MinSolver$MinSolutionIterator: int[] getLifters()>();

        $r9 = staticinvoke <minsolver.MinSolver$MinTwoWayTranslator: kodkod.instance.Instance access$3(minsolver.fol2sat.MinTranslation,kodkod.instance.Bounds,java.util.Map,int[])>($r2, $r6, $r7, $r8);

        return $r9;
    }

    public java.lang.String getLiftersList(java.util.Iterator)
    {
        minsolver.MinSolver r0;
        java.lang.String $r2;
        java.util.Iterator r1;

        r0 := @this: minsolver.MinSolver;

        r1 := @parameter0: java.util.Iterator;

        $r2 = virtualinvoke r0.<minsolver.MinSolver: java.lang.String getLiftersList(java.util.Iterator,java.util.Map,java.util.Map)>(r1, null, null);

        return $r2;
    }

    public java.lang.String getLiftersList(java.util.Iterator, java.util.Map, java.util.Map)
    {
        minsolver.MinSolver$MinSolutionIterator r1;
        minsolver.fol2sat.MinTranslation $r2;
        kodkod.instance.Bounds r7;
        java.util.Map $r10, r22, r23;
        boolean $z0, $z1, $z2;
        kodkod.engine.config.Reporter $r5;
        java.util.Set $r11;
        java.lang.Exception $r26;
        java.lang.StringBuilder $r25, $r29;
        kodkod.ast.Relation r14;
        kodkod.engine.config.Options $r4;
        kodkod.instance.Instance $r9;
        int $i0, $i2;
        java.lang.String $r21, $r24, r27;
        java.util.LinkedHashSet $r28;
        kodkod.instance.TupleSet r16;
        kodkod.instance.Tuple r19;
        java.util.Iterator r0, $r12, $r17;
        minsolver.MinSolver r3;
        minsolver.MyReporter $r6;
        java.lang.Object $r13, $r15, $r18;

        r3 := @this: minsolver.MinSolver;

        r0 := @parameter0: java.util.Iterator;

        r22 := @parameter1: java.util.Map;

        r23 := @parameter2: java.util.Map;

        r27 = "";

        r1 = (minsolver.MinSolver$MinSolutionIterator) r0;

        $r2 = staticinvoke <minsolver.MinSolver$MinSolutionIterator: minsolver.fol2sat.MinTranslation access$2(minsolver.MinSolver$MinSolutionIterator)>(r1);

        $r4 = r3.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r5 = virtualinvoke $r4.<kodkod.engine.config.Options: kodkod.engine.config.Reporter reporter()>();

        $r6 = (minsolver.MyReporter) $r5;

        r7 = $r6.<minsolver.MyReporter: kodkod.instance.Bounds skolemBounds>;

        $r28 = new java.util.LinkedHashSet;

        specialinvoke $r28.<java.util.LinkedHashSet: void <init>()>();

     label1:
        $r9 = virtualinvoke r3.<minsolver.MinSolver: kodkod.instance.Instance getLifters(java.util.Iterator)>(r0);

     label2:
        goto label4;

     label3:
        $r26 := @caughtexception;

        return "";

     label4:
        $r10 = virtualinvoke $r9.<kodkod.instance.Instance: java.util.Map relationTuples()>();

        $r11 = interfaceinvoke $r10.<java.util.Map: java.util.Set keySet()>();

        $r12 = interfaceinvoke $r11.<java.util.Set: java.util.Iterator iterator()>();

        goto label9;

     label5:
        $r13 = interfaceinvoke $r12.<java.util.Iterator: java.lang.Object next()>();

        r14 = (kodkod.ast.Relation) $r13;

        $r15 = interfaceinvoke $r10.<java.util.Map: java.lang.Object get(java.lang.Object)>(r14);

        r16 = (kodkod.instance.TupleSet) $r15;

        $r17 = virtualinvoke r16.<kodkod.instance.TupleSet: java.util.Iterator iterator()>();

        goto label8;

     label6:
        $r18 = interfaceinvoke $r17.<java.util.Iterator: java.lang.Object next()>();

        r19 = (kodkod.instance.Tuple) $r18;

        $z1 = staticinvoke <minsolver.MinSolver$MinSolutionIterator: boolean access$1(minsolver.MinSolver$MinSolutionIterator)>(r1);

        if $z1 != 0 goto label7;

        $i0 = staticinvoke <minsolver.MinSolver$MinTwoWayTranslator: int access$2(kodkod.instance.Bounds,minsolver.fol2sat.MinTranslation,kodkod.ast.Relation,kodkod.instance.Tuple)>(r7, $r2, r14, r19);

        $i2 = (int) -1;

        if $i0 != $i2 goto label7;

        goto label8;

     label7:
        $r29 = new java.lang.StringBuilder;

        $r21 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>(r27);

        specialinvoke $r29.<java.lang.StringBuilder: void <init>(java.lang.String)>($r21);

        $r24 = specialinvoke r3.<minsolver.MinSolver: java.lang.String lifterTupleToString(kodkod.ast.Relation,kodkod.instance.Tuple,java.util.Map,java.util.Map,java.util.Set)>(r14, r19, r22, r23, $r28);

        $r25 = virtualinvoke $r29.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r24);

        r27 = virtualinvoke $r25.<java.lang.StringBuilder: java.lang.String toString()>();

     label8:
        $z2 = interfaceinvoke $r17.<java.util.Iterator: boolean hasNext()>();

        if $z2 != 0 goto label6;

     label9:
        $z0 = interfaceinvoke $r12.<java.util.Iterator: boolean hasNext()>();

        if $z0 != 0 goto label5;

        return r27;

        catch java.lang.Exception from label1 to label2 with label3;
    }

    private java.lang.String lifterTupleToString(kodkod.ast.Relation, kodkod.instance.Tuple, java.util.Map, java.util.Map, java.util.Set)
    {
        java.util.Map r0, r10;
        boolean $z0, $z1, z2;
        java.util.Set r26;
        java.lang.StringBuilder $r1, $r7, $r8, $r11, $r12, $r20, $r22, $r23, $r27, $r31, $r33, $r37, $r38;
        kodkod.ast.Relation r2;
        java.util.ArrayList $r13;
        int $i0, i1, $i2, i3, $i4;
        java.lang.String $r3, $r4, $r6, $r9, $r15, $r17, $r24, $r25, $r28, $r29, $r30, $r32, $r34, $r35, $r36, $r39;
        kodkod.instance.Tuple r5;
        minsolver.MinSolver r40;
        java.lang.Object $r14, $r16, $r18, $r19, $r21;

        r40 := @this: minsolver.MinSolver;

        r2 := @parameter0: kodkod.ast.Relation;

        r5 := @parameter1: kodkod.instance.Tuple;

        r0 := @parameter2: java.util.Map;

        r10 := @parameter3: java.util.Map;

        r26 := @parameter4: java.util.Set;

        if r0 == null goto label11;

        if r10 == null goto label11;

        $r11 = new java.lang.StringBuilder;

        specialinvoke $r11.<java.lang.StringBuilder: void <init>(java.lang.String)>("[");

        $r12 = new java.lang.StringBuilder;

        specialinvoke $r12.<java.lang.StringBuilder: void <init>(java.lang.String)>("[");

        $r13 = new java.util.ArrayList;

        $i0 = virtualinvoke r5.<kodkod.instance.Tuple: int arity()>();

        specialinvoke $r13.<java.util.ArrayList: void <init>(int)>($i0);

        i1 = 0;

        goto label04;

     label01:
        $r14 = virtualinvoke r5.<kodkod.instance.Tuple: java.lang.Object atom(int)>(i1);

        $z0 = interfaceinvoke r10.<java.util.Map: boolean containsKey(java.lang.Object)>($r14);

        if $z0 == 0 goto label02;

        $r16 = interfaceinvoke r10.<java.util.Map: java.lang.Object get(java.lang.Object)>($r14);

        $r17 = (java.lang.String) $r16;

        interfaceinvoke $r13.<java.util.List: boolean add(java.lang.Object)>($r17);

        goto label03;

     label02:
        $r15 = virtualinvoke $r14.<java.lang.Object: java.lang.String toString()>();

        interfaceinvoke $r13.<java.util.List: boolean add(java.lang.Object)>($r15);

     label03:
        i1 = i1 + 1;

     label04:
        $i2 = virtualinvoke r5.<kodkod.instance.Tuple: int arity()>();

        if i1 < $i2 goto label01;

        z2 = 1;

        i3 = 0;

        goto label09;

     label05:
        if z2 != 0 goto label06;

        virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(", ");

        virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(",");

     label06:
        z2 = 0;

        $r18 = interfaceinvoke $r13.<java.util.List: java.lang.Object get(int)>(i3);

        $r19 = interfaceinvoke r0.<java.util.Map: java.lang.Object get(java.lang.Object)>($r18);

        $r25 = (java.lang.String) $r19;

        if $r25 == null goto label07;

        virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r25);

        virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r25);

        goto label08;

     label07:
        $r20 = new java.lang.StringBuilder;

        specialinvoke $r20.<java.lang.StringBuilder: void <init>(java.lang.String)>("NEW(");

        $r21 = virtualinvoke r5.<kodkod.instance.Tuple: java.lang.Object atom(int)>(i3);

        $r22 = virtualinvoke $r20.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r21);

        $r23 = virtualinvoke $r22.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");

        $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.String toString()>();

        virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r24);

        virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("NEW");

     label08:
        i3 = i3 + 1;

     label09:
        $i4 = virtualinvoke r5.<kodkod.instance.Tuple: int arity()>();

        if i3 < $i4 goto label05;

        virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("]");

        virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("]");

        $r27 = new java.lang.StringBuilder;

        $r28 = virtualinvoke r2.<kodkod.ast.Relation: java.lang.String toString()>();

        $r29 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>($r28);

        specialinvoke $r27.<java.lang.StringBuilder: void <init>(java.lang.String)>($r29);

        $r30 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.String toString()>();

        $r31 = virtualinvoke $r27.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r30);

        $r32 = virtualinvoke $r31.<java.lang.StringBuilder: java.lang.String toString()>();

        $z1 = interfaceinvoke r26.<java.util.Set: boolean add(java.lang.Object)>($r32);

        if $z1 == 0 goto label10;

        $r33 = new java.lang.StringBuilder;

        $r34 = virtualinvoke r2.<kodkod.ast.Relation: java.lang.String toString()>();

        $r35 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>($r34);

        specialinvoke $r33.<java.lang.StringBuilder: void <init>(java.lang.String)>($r35);

        $r36 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();

        $r37 = virtualinvoke $r33.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r36);

        $r38 = virtualinvoke $r37.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

        $r39 = virtualinvoke $r38.<java.lang.StringBuilder: java.lang.String toString()>();

        return $r39;

     label10:
        return "";

     label11:
        $r1 = new java.lang.StringBuilder;

        $r3 = virtualinvoke r2.<kodkod.ast.Relation: java.lang.String toString()>();

        $r4 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>($r3);

        specialinvoke $r1.<java.lang.StringBuilder: void <init>(java.lang.String)>($r4);

        $r6 = virtualinvoke r5.<kodkod.instance.Tuple: java.lang.String toString()>();

        $r7 = virtualinvoke $r1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r6);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.String toString()>();

        return $r9;
    }

    public kodkod.instance.Instance parseString(java.lang.String, java.util.Iterator) throws minsolver.ExplorationException
    {
        kodkod.instance.Instance $r3;
        minsolver.MinSolver r0;
        java.util.Iterator r2;
        java.lang.String r1;

        r0 := @this: minsolver.MinSolver;

        r1 := @parameter0: java.lang.String;

        r2 := @parameter1: java.util.Iterator;

        $r3 = virtualinvoke r0.<minsolver.MinSolver: kodkod.instance.Instance parseString(java.lang.String,java.util.Iterator,java.util.Map,java.util.Map)>(r1, r2, null, null);

        return $r3;
    }

    public kodkod.instance.Instance parseString(java.lang.String, java.util.Iterator, java.util.Map, java.util.Map) throws minsolver.ExplorationException
    {
        java.util.Map r21, r34;
        java.util.Set $r12;
        java.lang.StringBuilder $r32, $r38, $r39, $r46, $r50, $r54, $r58, $r68, $r70, $r74, $r76, $r78, $r79;
        kodkod.engine.config.Options $r8;
        java.util.ArrayList $r73;
        java.util.StringTokenizer $r72;
        java.lang.String $r0, $r1, $r3, $r5, $r6, $r15, r20, $r23, $r33, $r40, $r41, $r47, $r51, $r55, $r59, r61, r66, r67;
        kodkod.instance.Tuple r64, r65;
        kodkod.instance.Bounds r11;
        boolean $z0, $z1, $z2, $z3, $z4, $z5, $z6, $z7, $z8, z9;
        kodkod.engine.config.Reporter $r9;
        kodkod.ast.Relation r62, r63;
        kodkod.instance.Instance $r81;
        minsolver.ExplorationException $r69, $r71, $r75, $r77, $r80;
        int $i0, $i1, $i2, $i3, i4, $i5, $i7, $i9;
        kodkod.instance.Universe $r25, $r26;
        kodkod.instance.TupleFactory $r27;
        kodkod.instance.TupleSet $r16, $r29;
        java.util.Iterator $r13, $r17, r60;
        minsolver.MinSolver r7;
        kodkod.instance.Tuple[] $r28;
        minsolver.MyReporter $r10;
        java.lang.Object $r14, $r18, $r19, $r22, $r35, $r37, $r42, $r43;

        r7 := @this: minsolver.MinSolver;

        r61 := @parameter0: java.lang.String;

        r60 := @parameter1: java.util.Iterator;

        r21 := @parameter2: java.util.Map;

        r34 := @parameter3: java.util.Map;

        $r0 = virtualinvoke r61.<java.lang.String: java.lang.String trim()>();

        $i0 = virtualinvoke $r0.<java.lang.String: int indexOf(int)>(91);

        $i7 = (int) -1;

        if $i0 != $i7 goto label01;

        $r69 = new minsolver.ExplorationException;

        $r68 = new java.lang.StringBuilder;

        specialinvoke $r68.<java.lang.StringBuilder: void <init>(java.lang.String)>("Augmentation string did not contain a `[`");

        $r58 = virtualinvoke $r68.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(null);

        $r59 = virtualinvoke $r58.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r69.<minsolver.ExplorationException: void <init>(java.lang.String)>($r59);

        throw $r69;

     label01:
        $r1 = virtualinvoke $r0.<java.lang.String: java.lang.String substring(int,int)>(0, $i0);

        $i1 = virtualinvoke $r0.<java.lang.String: int indexOf(int)>(93);

        $i9 = (int) -1;

        if $i1 != $i9 goto label02;

        $r71 = new minsolver.ExplorationException;

        $r70 = new java.lang.StringBuilder;

        specialinvoke $r70.<java.lang.StringBuilder: void <init>(java.lang.String)>("Augmentation string must end with `]`");

        $r54 = virtualinvoke $r70.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r1);

        $r55 = virtualinvoke $r54.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r71.<minsolver.ExplorationException: void <init>(java.lang.String)>($r55);

        throw $r71;

     label02:
        $r72 = new java.util.StringTokenizer;

        $i2 = $i0 + 1;

        $r3 = virtualinvoke $r0.<java.lang.String: java.lang.String substring(int,int)>($i2, $i1);

        specialinvoke $r72.<java.util.StringTokenizer: void <init>(java.lang.String,java.lang.String)>($r3, ",");

        $r73 = new java.util.ArrayList;

        specialinvoke $r73.<java.util.ArrayList: void <init>()>();

        goto label04;

     label03:
        $r5 = virtualinvoke $r72.<java.util.StringTokenizer: java.lang.String nextToken()>();

        $r6 = virtualinvoke $r5.<java.lang.String: java.lang.String trim()>();

        virtualinvoke $r73.<java.util.ArrayList: boolean add(java.lang.Object)>($r6);

     label04:
        $z0 = virtualinvoke $r72.<java.util.StringTokenizer: boolean hasMoreTokens()>();

        if $z0 != 0 goto label03;

        $r8 = r7.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r9 = virtualinvoke $r8.<kodkod.engine.config.Options: kodkod.engine.config.Reporter reporter()>();

        $r10 = (minsolver.MyReporter) $r9;

        r11 = $r10.<minsolver.MyReporter: kodkod.instance.Bounds skolemBounds>;

        $r12 = virtualinvoke r11.<kodkod.instance.Bounds: java.util.Set relations()>();

        r62 = null;

        $r13 = interfaceinvoke $r12.<java.util.Set: java.util.Iterator iterator()>();

        goto label06;

     label05:
        $r14 = interfaceinvoke $r13.<java.util.Iterator: java.lang.Object next()>();

        r63 = (kodkod.ast.Relation) $r14;

        $r15 = virtualinvoke r63.<kodkod.ast.Relation: java.lang.String name()>();

        $z2 = virtualinvoke $r15.<java.lang.String: boolean equals(java.lang.Object)>($r1);

        if $z2 == 0 goto label06;

        r62 = r63;

        goto label07;

     label06:
        $z1 = interfaceinvoke $r13.<java.util.Iterator: boolean hasNext()>();

        if $z1 != 0 goto label05;

     label07:
        if r62 != null goto label08;

        $r75 = new minsolver.ExplorationException;

        $r74 = new java.lang.StringBuilder;

        specialinvoke $r74.<java.lang.StringBuilder: void <init>(java.lang.String)>("No relation found with name ");

        $r50 = virtualinvoke $r74.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r1);

        $r51 = virtualinvoke $r50.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r75.<minsolver.ExplorationException: void <init>(java.lang.String)>($r51);

        throw $r75;

     label08:
        $r16 = virtualinvoke r11.<kodkod.instance.Bounds: kodkod.instance.TupleSet upperBound(kodkod.ast.Relation)>(r62);

        if $r16 != null goto label09;

        $r77 = new minsolver.ExplorationException;

        $r76 = new java.lang.StringBuilder;

        specialinvoke $r76.<java.lang.StringBuilder: void <init>(java.lang.String)>("No upper bound given for ");

        $r46 = virtualinvoke $r76.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r1);

        $r47 = virtualinvoke $r46.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r77.<minsolver.ExplorationException: void <init>(java.lang.String)>($r47);

        throw $r77;

     label09:
        r64 = null;

        $r17 = virtualinvoke $r16.<kodkod.instance.TupleSet: java.util.Iterator iterator()>();

        goto label21;

     label10:
        $r18 = interfaceinvoke $r17.<java.util.Iterator: java.lang.Object next()>();

        r65 = (kodkod.instance.Tuple) $r18;

        z9 = 1;

        i4 = 0;

        goto label19;

     label11:
        $r19 = virtualinvoke $r73.<java.util.ArrayList: java.lang.Object get(int)>(i4);

        r20 = (java.lang.String) $r19;

        if r21 == null goto label17;

        if r34 == null goto label17;

        $r35 = virtualinvoke r65.<kodkod.instance.Tuple: java.lang.Object atom(int)>(i4);

        $z5 = interfaceinvoke r34.<java.util.Map: boolean containsKey(java.lang.Object)>($r35);

        if $z5 == 0 goto label12;

        $r43 = interfaceinvoke r34.<java.util.Map: java.lang.Object get(java.lang.Object)>($r35);

        r66 = (java.lang.String) $r43;

        goto label13;

     label12:
        r66 = virtualinvoke $r35.<java.lang.Object: java.lang.String toString()>();

     label13:
        $z6 = interfaceinvoke r21.<java.util.Map: boolean containsKey(java.lang.Object)>(r20);

        if $z6 == 0 goto label14;

        $r42 = interfaceinvoke r21.<java.util.Map: java.lang.Object get(java.lang.Object)>(r20);

        r67 = (java.lang.String) $r42;

        goto label15;

     label14:
        r67 = "";

     label15:
        $i3 = virtualinvoke r67.<java.lang.String: int length()>();

        if $i3 <= 0 goto label16;

        $z8 = virtualinvoke r67.<java.lang.String: boolean equals(java.lang.Object)>(r66);

        if $z8 != 0 goto label18;

        z9 = 0;

        goto label20;

     label16:
        $r78 = new java.lang.StringBuilder;

        specialinvoke $r78.<java.lang.StringBuilder: void <init>(java.lang.String)>("NEW(");

        $r37 = virtualinvoke r65.<kodkod.instance.Tuple: java.lang.Object atom(int)>(i4);

        $r38 = virtualinvoke $r78.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r37);

        $r39 = virtualinvoke $r38.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");

        $r40 = virtualinvoke $r39.<java.lang.StringBuilder: java.lang.String toString()>();

        $r41 = virtualinvoke $r40.<java.lang.String: java.lang.String toString()>();

        $z7 = virtualinvoke $r41.<java.lang.String: boolean equals(java.lang.Object)>(r20);

        if $z7 != 0 goto label18;

        z9 = 0;

        goto label20;

     label17:
        $r22 = virtualinvoke r65.<kodkod.instance.Tuple: java.lang.Object atom(int)>(i4);

        $r23 = virtualinvoke $r22.<java.lang.Object: java.lang.String toString()>();

        $z4 = virtualinvoke $r23.<java.lang.String: boolean equals(java.lang.Object)>(r20);

        if $z4 != 0 goto label18;

        z9 = 0;

        goto label20;

     label18:
        i4 = i4 + 1;

     label19:
        $i5 = virtualinvoke r65.<kodkod.instance.Tuple: int arity()>();

        if i4 < $i5 goto label11;

     label20:
        if z9 == 0 goto label21;

        r64 = r65;

        goto label22;

     label21:
        $z3 = interfaceinvoke $r17.<java.util.Iterator: boolean hasNext()>();

        if $z3 != 0 goto label10;

     label22:
        if r64 != null goto label23;

        $r80 = new minsolver.ExplorationException;

        $r79 = new java.lang.StringBuilder;

        specialinvoke $r79.<java.lang.StringBuilder: void <init>(java.lang.String)>("No matching tuple found for the given augmentation string: ");

        $r32 = virtualinvoke $r79.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r0);

        $r33 = virtualinvoke $r32.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r80.<minsolver.ExplorationException: void <init>(java.lang.String)>($r33);

        throw $r80;

     label23:
        $r81 = new kodkod.instance.Instance;

        $r25 = virtualinvoke r11.<kodkod.instance.Bounds: kodkod.instance.Universe universe()>();

        specialinvoke $r81.<kodkod.instance.Instance: void <init>(kodkod.instance.Universe)>($r25);

        $r26 = virtualinvoke r11.<kodkod.instance.Bounds: kodkod.instance.Universe universe()>();

        $r27 = virtualinvoke $r26.<kodkod.instance.Universe: kodkod.instance.TupleFactory factory()>();

        $r28 = newarray (kodkod.instance.Tuple)[0];

        $r29 = virtualinvoke $r27.<kodkod.instance.TupleFactory: kodkod.instance.TupleSet setOf(kodkod.instance.Tuple,kodkod.instance.Tuple[])>(r64, $r28);

        virtualinvoke $r81.<kodkod.instance.Instance: void add(kodkod.ast.Relation,kodkod.instance.TupleSet)>(r62, $r29);

        return $r81;
    }

    public kodkod.instance.Bounds getSkolemBounds()
    {
        kodkod.engine.config.Options $r1;
        minsolver.MinSolver r0;
        kodkod.instance.Bounds $r4;
        kodkod.engine.config.Reporter $r2;
        minsolver.MyReporter $r3;

        r0 := @this: minsolver.MinSolver;

        $r1 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r2 = virtualinvoke $r1.<kodkod.engine.config.Options: kodkod.engine.config.Reporter reporter()>();

        $r3 = (minsolver.MyReporter) $r2;

        $r4 = $r3.<minsolver.MyReporter: kodkod.instance.Bounds skolemBounds>;

        return $r4;
    }

    public java.lang.String toString()
    {
        kodkod.engine.config.Options $r1;
        minsolver.MinSolver r0;
        java.lang.String $r2;

        r0 := @this: minsolver.MinSolver;

        $r1 = r0.<minsolver.MinSolver: kodkod.engine.config.Options options>;

        $r2 = virtualinvoke $r1.<kodkod.engine.config.Options: java.lang.String toString()>();

        return $r2;
    }

    private static minsolver.MinSolution sat(kodkod.instance.Bounds, minsolver.fol2sat.MinTranslation, minsolver.MinStatistics)
    {
        kodkod.instance.Instance $r2, $r4;
        kodkod.instance.Bounds r3;
        minsolver.MinSolution $r5;
        minsolver.fol2sat.MinTranslation r1;
        minsolver.MinSATSolver $r6;
        minsolver.MinStatistics r0;

        r3 := @parameter0: kodkod.instance.Bounds;

        r1 := @parameter1: minsolver.fol2sat.MinTranslation;

        r0 := @parameter2: minsolver.MinStatistics;

        $r2 = virtualinvoke r1.<minsolver.fol2sat.MinTranslation: kodkod.instance.Instance interpret()>();

        $r4 = staticinvoke <minsolver.MinSolver: kodkod.instance.Instance padInstance(kodkod.instance.Instance,kodkod.instance.Bounds)>($r2, r3);

        $r5 = staticinvoke <minsolver.MinSolution: minsolver.MinSolution satisfiable(minsolver.MinStatistics,kodkod.instance.Instance,minsolver.MinSolution$MinimizationHistory,int[])>(r0, $r4, null, null);

        $r6 = virtualinvoke r1.<minsolver.fol2sat.MinTranslation: minsolver.MinSATSolver cnf()>();

        virtualinvoke $r6.<minsolver.MinSATSolver: void free()>();

        return $r5;
    }

    private static minsolver.MinSolution unsat(minsolver.fol2sat.MinTranslation, minsolver.MinStatistics)
    {
        minsolver.MinResolutionBasedProof $r5;
        kodkod.engine.satlab.SATProver $r6;
        minsolver.fol2sat.MinTranslation r0;
        minsolver.MinSolution $r4, $r7;
        minsolver.MinSATSolver $r1;
        minsolver.fol2sat.MinTranslationLog $r2;
        minsolver.MinStatistics r3;
        boolean $z0;

        r0 := @parameter0: minsolver.fol2sat.MinTranslation;

        r3 := @parameter1: minsolver.MinStatistics;

        $r1 = virtualinvoke r0.<minsolver.fol2sat.MinTranslation: minsolver.MinSATSolver cnf()>();

        $r2 = virtualinvoke r0.<minsolver.fol2sat.MinTranslation: minsolver.fol2sat.MinTranslationLog log()>();

        $z0 = $r1 instanceof kodkod.engine.satlab.SATProver;

        if $z0 == 0 goto label1;

        if $r2 == null goto label1;

        $r5 = new minsolver.MinResolutionBasedProof;

        $r6 = (kodkod.engine.satlab.SATProver) $r1;

        specialinvoke $r5.<minsolver.MinResolutionBasedProof: void <init>(kodkod.engine.satlab.SATProver,minsolver.fol2sat.MinTranslationLog)>($r6, $r2);

        $r7 = staticinvoke <minsolver.MinSolution: minsolver.MinSolution unsatisfiable(minsolver.MinStatistics,minsolver.MinProof,minsolver.MinSolution$MinimizationHistory,int[])>(r3, $r5, null, null);

        return $r7;

     label1:
        $r4 = staticinvoke <minsolver.MinSolution: minsolver.MinSolution unsatisfiable(minsolver.MinStatistics,minsolver.MinProof,minsolver.MinSolution$MinimizationHistory,int[])>(r3, null, null, null);

        interfaceinvoke $r1.<kodkod.engine.satlab.SATSolver: void free()>();

        return $r4;
    }

    private static int trivialPrimaries(kodkod.instance.Bounds)
    {
        java.util.Iterator $r2;
        java.util.Set $r1;
        kodkod.instance.Bounds r0;
        int $i0, $i1, $i2, i3;
        java.lang.Object $r3;
        kodkod.ast.Relation r4;
        boolean $z0;
        kodkod.instance.TupleSet $r5, $r6;

        r0 := @parameter0: kodkod.instance.Bounds;

        i3 = 0;

        $r1 = virtualinvoke r0.<kodkod.instance.Bounds: java.util.Set relations()>();

        $r2 = interfaceinvoke $r1.<java.util.Set: java.util.Iterator iterator()>();

        goto label2;

     label1:
        $r3 = interfaceinvoke $r2.<java.util.Iterator: java.lang.Object next()>();

        r4 = (kodkod.ast.Relation) $r3;

        $r5 = virtualinvoke r0.<kodkod.instance.Bounds: kodkod.instance.TupleSet upperBound(kodkod.ast.Relation)>(r4);

        $i0 = virtualinvoke $r5.<kodkod.instance.TupleSet: int size()>();

        $r6 = virtualinvoke r0.<kodkod.instance.Bounds: kodkod.instance.TupleSet lowerBound(kodkod.ast.Relation)>(r4);

        $i1 = virtualinvoke $r6.<kodkod.instance.TupleSet: int size()>();

        $i2 = $i0 - $i1;

        i3 = i3 + $i2;

     label2:
        $z0 = interfaceinvoke $r2.<java.util.Iterator: boolean hasNext()>();

        if $z0 != 0 goto label1;

        return i3;
    }

    private static minsolver.MinSolution trivial(kodkod.instance.Bounds, minsolver.fol2sat.MinTrivialFormulaException, long)
    {
        minsolver.fol2sat.MinTrivialFormulaException r1;
        kodkod.engine.bool.BooleanConstant $r3;
        long l1;
        minsolver.MinProof $r5;
        kodkod.instance.Instance $r8, $r10;
        kodkod.instance.Bounds $r2, $r7, r9;
        minsolver.MinSolution $r6, $r11;
        int $i0;
        minsolver.MinStatistics $r0;
        minsolver.fol2sat.MinTranslationLog $r4;
        boolean $z0;

        r9 := @parameter0: kodkod.instance.Bounds;

        r1 := @parameter1: minsolver.fol2sat.MinTrivialFormulaException;

        l1 := @parameter2: long;

        $r0 = new minsolver.MinStatistics;

        $r2 = virtualinvoke r1.<minsolver.fol2sat.MinTrivialFormulaException: kodkod.instance.Bounds bounds()>();

        $i0 = staticinvoke <minsolver.MinSolver: int trivialPrimaries(kodkod.instance.Bounds)>($r2);

        specialinvoke $r0.<minsolver.MinStatistics: void <init>(int,int,int,long,long)>($i0, 0, 0, l1, 0L);

        $r3 = virtualinvoke r1.<minsolver.fol2sat.MinTrivialFormulaException: kodkod.engine.bool.BooleanConstant value()>();

        $z0 = virtualinvoke $r3.<kodkod.engine.bool.BooleanConstant: boolean booleanValue()>();

        if $z0 == 0 goto label1;

        $r7 = virtualinvoke r1.<minsolver.fol2sat.MinTrivialFormulaException: kodkod.instance.Bounds bounds()>();

        $r8 = staticinvoke <minsolver.MinSolver: kodkod.instance.Instance toInstance(kodkod.instance.Bounds)>($r7);

        $r10 = staticinvoke <minsolver.MinSolver: kodkod.instance.Instance padInstance(kodkod.instance.Instance,kodkod.instance.Bounds)>($r8, r9);

        $r11 = staticinvoke <minsolver.MinSolution: minsolver.MinSolution triviallySatisfiable(minsolver.MinStatistics,kodkod.instance.Instance,minsolver.MinSolution$MinimizationHistory,int[])>($r0, $r10, null, null);

        return $r11;

     label1:
        $r4 = virtualinvoke r1.<minsolver.fol2sat.MinTrivialFormulaException: minsolver.fol2sat.MinTranslationLog log()>();

        $r5 = staticinvoke <minsolver.MinSolver: minsolver.MinProof trivialProof(minsolver.fol2sat.MinTranslationLog)>($r4);

        $r6 = staticinvoke <minsolver.MinSolution: minsolver.MinSolution triviallyUnsatisfiable(minsolver.MinStatistics,minsolver.MinProof,minsolver.MinSolution$MinimizationHistory,int[])>($r0, $r5, null, null);

        return $r6;
    }

    private static minsolver.MinProof trivialProof(minsolver.fol2sat.MinTranslationLog)
    {
        minsolver.fol2sat.MinTranslationLog r0;
        minsolver.MinTrivialProof $r1;

        r0 := @parameter0: minsolver.fol2sat.MinTranslationLog;

        if r0 != null goto label1;

        $r1 = null;

        goto label2;

     label1:
        $r1 = new minsolver.MinTrivialProof;

        specialinvoke $r1.<minsolver.MinTrivialProof: void <init>(minsolver.fol2sat.MinTranslationLog)>(r0);

     label2:
        return $r1;
    }

    private static kodkod.instance.Instance padInstance(kodkod.instance.Instance, kodkod.instance.Bounds)
    {
        java.util.Iterator $r2;
        kodkod.util.ints.IntSet $r6;
        java.util.Set $r1;
        kodkod.util.ints.IntIterator $r7;
        kodkod.instance.Instance r4;
        kodkod.instance.Bounds r0;
        int $i0;
        java.lang.Object $r3;
        kodkod.ast.Relation r9;
        boolean $z0, $z1, $z2;
        kodkod.instance.TupleSet $r5, $r8;

        r4 := @parameter0: kodkod.instance.Instance;

        r0 := @parameter1: kodkod.instance.Bounds;

        $r1 = virtualinvoke r0.<kodkod.instance.Bounds: java.util.Set relations()>();

        $r2 = interfaceinvoke $r1.<java.util.Set: java.util.Iterator iterator()>();

        goto label2;

     label1:
        $r3 = interfaceinvoke $r2.<java.util.Iterator: java.lang.Object next()>();

        r9 = (kodkod.ast.Relation) $r3;

        $z0 = virtualinvoke r4.<kodkod.instance.Instance: boolean contains(kodkod.ast.Relation)>(r9);

        if $z0 != 0 goto label2;

        $r5 = virtualinvoke r0.<kodkod.instance.Bounds: kodkod.instance.TupleSet lowerBound(kodkod.ast.Relation)>(r9);

        virtualinvoke r4.<kodkod.instance.Instance: void add(kodkod.ast.Relation,kodkod.instance.TupleSet)>(r9, $r5);

     label2:
        $z2 = interfaceinvoke $r2.<java.util.Iterator: boolean hasNext()>();

        if $z2 != 0 goto label1;

        $r6 = virtualinvoke r0.<kodkod.instance.Bounds: kodkod.util.ints.IntSet ints()>();

        $r7 = interfaceinvoke $r6.<kodkod.util.ints.IntSet: kodkod.util.ints.IntIterator iterator()>();

        goto label4;

     label3:
        $i0 = interfaceinvoke $r7.<kodkod.util.ints.IntIterator: int next()>();

        $r8 = virtualinvoke r0.<kodkod.instance.Bounds: kodkod.instance.TupleSet exactBound(int)>($i0);

        virtualinvoke r4.<kodkod.instance.Instance: void add(int,kodkod.instance.TupleSet)>($i0, $r8);

     label4:
        $z1 = interfaceinvoke $r7.<kodkod.util.ints.IntIterator: boolean hasNext()>();

        if $z1 != 0 goto label3;

        return r4;
    }

    private static kodkod.instance.Instance toInstance(kodkod.instance.Bounds)
    {
        java.util.Iterator $r4;
        kodkod.util.ints.IntSet $r7;
        java.util.Set $r3;
        kodkod.util.ints.IntIterator $r8;
        kodkod.instance.Instance $r0;
        kodkod.instance.Bounds r1;
        int $i0;
        java.lang.Object $r5;
        kodkod.instance.Universe $r2;
        kodkod.ast.Relation r10;
        boolean $z0, $z1;
        kodkod.instance.TupleSet $r6, $r9;

        r1 := @parameter0: kodkod.instance.Bounds;

        $r0 = new kodkod.instance.Instance;

        $r2 = virtualinvoke r1.<kodkod.instance.Bounds: kodkod.instance.Universe universe()>();

        specialinvoke $r0.<kodkod.instance.Instance: void <init>(kodkod.instance.Universe)>($r2);

        $r3 = virtualinvoke r1.<kodkod.instance.Bounds: java.util.Set relations()>();

        $r4 = interfaceinvoke $r3.<java.util.Set: java.util.Iterator iterator()>();

        goto label2;

     label1:
        $r5 = interfaceinvoke $r4.<java.util.Iterator: java.lang.Object next()>();

        r10 = (kodkod.ast.Relation) $r5;

        $r6 = virtualinvoke r1.<kodkod.instance.Bounds: kodkod.instance.TupleSet lowerBound(kodkod.ast.Relation)>(r10);

        virtualinvoke $r0.<kodkod.instance.Instance: void add(kodkod.ast.Relation,kodkod.instance.TupleSet)>(r10, $r6);

     label2:
        $z0 = interfaceinvoke $r4.<java.util.Iterator: boolean hasNext()>();

        if $z0 != 0 goto label1;

        $r7 = virtualinvoke r1.<kodkod.instance.Bounds: kodkod.util.ints.IntSet ints()>();

        $r8 = interfaceinvoke $r7.<kodkod.util.ints.IntSet: kodkod.util.ints.IntIterator iterator()>();

        goto label4;

     label3:
        $i0 = interfaceinvoke $r8.<kodkod.util.ints.IntIterator: int next()>();

        $r9 = virtualinvoke r1.<kodkod.instance.Bounds: kodkod.instance.TupleSet exactBound(int)>($i0);

        virtualinvoke $r0.<kodkod.instance.Instance: void add(int,kodkod.instance.TupleSet)>($i0, $r9);

     label4:
        $z1 = interfaceinvoke $r8.<kodkod.util.ints.IntIterator: boolean hasNext()>();

        if $z1 != 0 goto label3;

        return $r0;
    }

    static minsolver.MinSolution access$0(minsolver.fol2sat.MinTranslation, minsolver.MinStatistics)
    {
        minsolver.fol2sat.MinTranslation r0;
        minsolver.MinSolution $r2;
        minsolver.MinStatistics r1;

        r0 := @parameter0: minsolver.fol2sat.MinTranslation;

        r1 := @parameter1: minsolver.MinStatistics;

        $r2 = staticinvoke <minsolver.MinSolver: minsolver.MinSolution unsat(minsolver.fol2sat.MinTranslation,minsolver.MinStatistics)>(r0, r1);

        return $r2;
    }

    static kodkod.instance.Instance access$1(kodkod.instance.Instance, kodkod.instance.Bounds)
    {
        kodkod.instance.Instance r0, $r2;
        kodkod.instance.Bounds r1;

        r0 := @parameter0: kodkod.instance.Instance;

        r1 := @parameter1: kodkod.instance.Bounds;

        $r2 = staticinvoke <minsolver.MinSolver: kodkod.instance.Instance padInstance(kodkod.instance.Instance,kodkod.instance.Bounds)>(r0, r1);

        return $r2;
    }

    static kodkod.instance.Instance access$2(kodkod.instance.Bounds)
    {
        kodkod.instance.Instance $r1;
        kodkod.instance.Bounds r0;

        r0 := @parameter0: kodkod.instance.Bounds;

        $r1 = staticinvoke <minsolver.MinSolver: kodkod.instance.Instance toInstance(kodkod.instance.Bounds)>(r0);

        return $r1;
    }

    static minsolver.MinProof access$3(minsolver.fol2sat.MinTranslationLog)
    {
        minsolver.MinProof $r1;
        minsolver.fol2sat.MinTranslationLog r0;

        r0 := @parameter0: minsolver.fol2sat.MinTranslationLog;

        $r1 = staticinvoke <minsolver.MinSolver: minsolver.MinProof trivialProof(minsolver.fol2sat.MinTranslationLog)>(r0);

        return $r1;
    }

    static minsolver.MinSolver$MinSolutionIterator access$4(minsolver.MinSolver)
    {
        minsolver.MinSolver r0;
        minsolver.MinSolver$MinSolutionIterator $r1;

        r0 := @parameter0: minsolver.MinSolver;

        $r1 = r0.<minsolver.MinSolver: minsolver.MinSolver$MinSolutionIterator activeIterator>;

        return $r1;
    }

    static void access$5(minsolver.MinSolver, minsolver.MinSolver$MinSolutionIterator)
    {
        minsolver.MinSolver r0;
        minsolver.MinSolver$MinSolutionIterator r1;

        r0 := @parameter0: minsolver.MinSolver;

        r1 := @parameter1: minsolver.MinSolver$MinSolutionIterator;

        r0.<minsolver.MinSolver: minsolver.MinSolver$MinSolutionIterator activeIterator> = r1;

        return;
    }
}
