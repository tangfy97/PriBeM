public abstract class org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor extends java.lang.Object implements org.springframework.remoting.httpinvoker.HttpInvokerRequestExecutor, org.springframework.beans.factory.BeanClassLoaderAware
{
    public static final java.lang.String CONTENT_TYPE_SERIALIZED_OBJECT;
    protected static final java.lang.String HTTP_METHOD_POST;
    protected static final java.lang.String HTTP_HEADER_ACCEPT_LANGUAGE;
    protected static final java.lang.String HTTP_HEADER_ACCEPT_ENCODING;
    protected static final java.lang.String HTTP_HEADER_CONTENT_ENCODING;
    protected static final java.lang.String HTTP_HEADER_CONTENT_TYPE;
    protected static final java.lang.String HTTP_HEADER_CONTENT_LENGTH;
    protected static final java.lang.String ENCODING_GZIP;
    private static final int SERIALIZED_INVOCATION_BYTE_ARRAY_INITIAL_SIZE;
    protected final org.apache.commons.logging.Log logger;
    private java.lang.String contentType;
    private boolean acceptGzipEncoding;
    private java.lang.ClassLoader beanClassLoader;

    public void <init>()
    {
        java.lang.Class $r1;
        org.apache.commons.logging.Log $r2;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        $r1 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();

        $r2 = staticinvoke <org.apache.commons.logging.LogFactory: org.apache.commons.logging.Log getLog(java.lang.Class)>($r1);

        r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: org.apache.commons.logging.Log logger> = $r2;

        r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String contentType> = "application/x-java-serialized-object";

        r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: boolean acceptGzipEncoding> = 1;

        return;
    }

    public void setContentType(java.lang.String)
    {
        java.lang.String r0;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r1;

        r1 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r0 := @parameter0: java.lang.String;

        staticinvoke <org.springframework.util.Assert: void notNull(java.lang.Object,java.lang.String)>(r0, "\'contentType\' must not be null");

        r1.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String contentType> = r0;

        return;
    }

    public java.lang.String getContentType()
    {
        java.lang.String $r1;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        $r1 = r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String contentType>;

        return $r1;
    }

    public void setAcceptGzipEncoding(boolean)
    {
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;
        boolean z0;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        z0 := @parameter0: boolean;

        r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: boolean acceptGzipEncoding> = z0;

        return;
    }

    public boolean isAcceptGzipEncoding()
    {
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;
        boolean $z0;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        $z0 = r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: boolean acceptGzipEncoding>;

        return $z0;
    }

    public void setBeanClassLoader(java.lang.ClassLoader)
    {
        java.lang.ClassLoader r1;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r1 := @parameter0: java.lang.ClassLoader;

        r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.ClassLoader beanClassLoader> = r1;

        return;
    }

    protected java.lang.ClassLoader getBeanClassLoader()
    {
        java.lang.ClassLoader $r1;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        $r1 = r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.ClassLoader beanClassLoader>;

        return $r1;
    }

    public final org.springframework.remoting.support.RemoteInvocationResult executeRequest(org.springframework.remoting.httpinvoker.HttpInvokerClientConfiguration, org.springframework.remoting.support.RemoteInvocation) throws java.lang.Exception
    {
        java.io.ByteArrayOutputStream $r2;
        org.springframework.remoting.support.RemoteInvocation r1;
        org.springframework.remoting.support.RemoteInvocationResult $r5;
        int $i0;
        org.apache.commons.logging.Log $r3, $r7;
        java.lang.StringBuilder $r6, $r9, $r10, $r11;
        java.lang.String $r8, $r12;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;
        org.springframework.remoting.httpinvoker.HttpInvokerClientConfiguration r4;
        boolean $z0;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r4 := @parameter0: org.springframework.remoting.httpinvoker.HttpInvokerClientConfiguration;

        r1 := @parameter1: org.springframework.remoting.support.RemoteInvocation;

        $r2 = virtualinvoke r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.io.ByteArrayOutputStream getByteArrayOutputStream(org.springframework.remoting.support.RemoteInvocation)>(r1);

        $r3 = r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: org.apache.commons.logging.Log logger>;

        $z0 = interfaceinvoke $r3.<org.apache.commons.logging.Log: boolean isDebugEnabled()>();

        if $z0 == 0 goto label1;

        $r7 = r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: org.apache.commons.logging.Log logger>;

        $r6 = new java.lang.StringBuilder;

        specialinvoke $r6.<java.lang.StringBuilder: void <init>(java.lang.String)>("Sending HTTP invoker request for service at [");

        $r8 = interfaceinvoke r4.<org.springframework.remoting.httpinvoker.HttpInvokerClientConfiguration: java.lang.String getServiceUrl()>();

        $r9 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r8);

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("], with size ");

        $i0 = virtualinvoke $r2.<java.io.ByteArrayOutputStream: int size()>();

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i0);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();

        interfaceinvoke $r7.<org.apache.commons.logging.Log: void debug(java.lang.Object)>($r12);

     label1:
        $r5 = virtualinvoke r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: org.springframework.remoting.support.RemoteInvocationResult doExecuteRequest(org.springframework.remoting.httpinvoker.HttpInvokerClientConfiguration,java.io.ByteArrayOutputStream)>(r4, $r2);

        return $r5;
    }

    protected java.io.ByteArrayOutputStream getByteArrayOutputStream(org.springframework.remoting.support.RemoteInvocation) throws java.io.IOException
    {
        org.springframework.remoting.support.RemoteInvocation r2;
        java.io.ByteArrayOutputStream $r0;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r1;

        r1 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r2 := @parameter0: org.springframework.remoting.support.RemoteInvocation;

        $r0 = new java.io.ByteArrayOutputStream;

        specialinvoke $r0.<java.io.ByteArrayOutputStream: void <init>(int)>(1024);

        virtualinvoke r1.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: void writeRemoteInvocation(org.springframework.remoting.support.RemoteInvocation,java.io.OutputStream)>(r2, $r0);

        return $r0;
    }

    protected void writeRemoteInvocation(org.springframework.remoting.support.RemoteInvocation, java.io.OutputStream) throws java.io.IOException
    {
        java.io.OutputStream r2, $r3;
        java.lang.Throwable $r5;
        org.springframework.remoting.support.RemoteInvocation r4;
        java.io.ObjectOutputStream $r0;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r1;

        r1 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r4 := @parameter0: org.springframework.remoting.support.RemoteInvocation;

        r2 := @parameter1: java.io.OutputStream;

        $r0 = new java.io.ObjectOutputStream;

        $r3 = virtualinvoke r1.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.io.OutputStream decorateOutputStream(java.io.OutputStream)>(r2);

        specialinvoke $r0.<java.io.ObjectOutputStream: void <init>(java.io.OutputStream)>($r3);

     label1:
        virtualinvoke r1.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: void doWriteRemoteInvocation(org.springframework.remoting.support.RemoteInvocation,java.io.ObjectOutputStream)>(r4, $r0);

        goto label3;

     label2:
        $r5 := @caughtexception;

        virtualinvoke $r0.<java.io.ObjectOutputStream: void close()>();

        throw $r5;

     label3:
        virtualinvoke $r0.<java.io.ObjectOutputStream: void close()>();

        return;

        catch java.lang.Throwable from label1 to label2 with label2;
    }

    protected java.io.OutputStream decorateOutputStream(java.io.OutputStream) throws java.io.IOException
    {
        java.io.OutputStream r0;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r1;

        r1 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r0 := @parameter0: java.io.OutputStream;

        return r0;
    }

    protected void doWriteRemoteInvocation(org.springframework.remoting.support.RemoteInvocation, java.io.ObjectOutputStream) throws java.io.IOException
    {
        org.springframework.remoting.support.RemoteInvocation r1;
        java.io.ObjectOutputStream r0;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r2;

        r2 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r1 := @parameter0: org.springframework.remoting.support.RemoteInvocation;

        r0 := @parameter1: java.io.ObjectOutputStream;

        virtualinvoke r0.<java.io.ObjectOutputStream: void writeObject(java.lang.Object)>(r1);

        return;
    }

    protected abstract org.springframework.remoting.support.RemoteInvocationResult doExecuteRequest(org.springframework.remoting.httpinvoker.HttpInvokerClientConfiguration, java.io.ByteArrayOutputStream) throws java.lang.Exception;

    protected org.springframework.remoting.support.RemoteInvocationResult readRemoteInvocationResult(java.io.InputStream, java.lang.String) throws java.io.IOException, java.lang.ClassNotFoundException
    {
        java.lang.Throwable $r6;
        org.springframework.remoting.support.RemoteInvocationResult $r5;
        java.io.ObjectInputStream $r4;
        java.lang.String r3;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r0;
        java.io.InputStream r1, $r2;

        r0 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r1 := @parameter0: java.io.InputStream;

        r3 := @parameter1: java.lang.String;

        $r2 = virtualinvoke r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.io.InputStream decorateInputStream(java.io.InputStream)>(r1);

        $r4 = virtualinvoke r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.io.ObjectInputStream createObjectInputStream(java.io.InputStream,java.lang.String)>($r2, r3);

     label1:
        $r5 = virtualinvoke r0.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: org.springframework.remoting.support.RemoteInvocationResult doReadRemoteInvocationResult(java.io.ObjectInputStream)>($r4);

     label2:
        virtualinvoke $r4.<java.io.ObjectInputStream: void close()>();

        return $r5;

     label3:
        $r6 := @caughtexception;

        virtualinvoke $r4.<java.io.ObjectInputStream: void close()>();

        throw $r6;

        catch java.lang.Throwable from label1 to label2 with label3;
    }

    protected java.io.InputStream decorateInputStream(java.io.InputStream) throws java.io.IOException
    {
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r1;
        java.io.InputStream r0;

        r1 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r0 := @parameter0: java.io.InputStream;

        return r0;
    }

    protected java.io.ObjectInputStream createObjectInputStream(java.io.InputStream, java.lang.String) throws java.io.IOException
    {
        java.lang.ClassLoader $r3;
        java.lang.String r4;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r2;
        org.springframework.remoting.rmi.CodebaseAwareObjectInputStream $r0;
        java.io.InputStream r1;

        r2 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r1 := @parameter0: java.io.InputStream;

        r4 := @parameter1: java.lang.String;

        $r0 = new org.springframework.remoting.rmi.CodebaseAwareObjectInputStream;

        $r3 = virtualinvoke r2.<org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.ClassLoader getBeanClassLoader()>();

        specialinvoke $r0.<org.springframework.remoting.rmi.CodebaseAwareObjectInputStream: void <init>(java.io.InputStream,java.lang.ClassLoader,java.lang.String)>(r1, $r3, r4);

        return $r0;
    }

    protected org.springframework.remoting.support.RemoteInvocationResult doReadRemoteInvocationResult(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException
    {
        java.io.ObjectInputStream r0;
        java.rmi.RemoteException $r3;
        org.springframework.remoting.support.RemoteInvocationResult $r2;
        java.lang.Object $r1;
        java.lang.StringBuilder $r4, $r7, $r8, $r9;
        java.lang.Class $r5;
        java.lang.String $r6, $r10;
        org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor r11;
        boolean $z0;

        r11 := @this: org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor;

        r0 := @parameter0: java.io.ObjectInputStream;

        $r1 = virtualinvoke r0.<java.io.ObjectInputStream: java.lang.Object readObject()>();

        $z0 = $r1 instanceof org.springframework.remoting.support.RemoteInvocationResult;

        if $z0 != 0 goto label1;

        $r3 = new java.rmi.RemoteException;

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>(java.lang.String)>("Deserialized object needs to be assignable to type [");

        $r5 = class "Lorg/springframework/remoting/support/RemoteInvocationResult;";

        $r6 = virtualinvoke $r5.<java.lang.Class: java.lang.String getName()>();

        $r7 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r6);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("]: ");

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r1);

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r3.<java.rmi.RemoteException: void <init>(java.lang.String)>($r10);

        throw $r3;

     label1:
        $r2 = (org.springframework.remoting.support.RemoteInvocationResult) $r1;

        return $r2;
    }

    public static void <clinit>()
    {
        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: int SERIALIZED_INVOCATION_BYTE_ARRAY_INITIAL_SIZE> = 1024;

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String ENCODING_GZIP> = "gzip";

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String HTTP_HEADER_CONTENT_LENGTH> = "Content-Length";

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String HTTP_HEADER_CONTENT_TYPE> = "Content-Type";

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String HTTP_HEADER_CONTENT_ENCODING> = "Content-Encoding";

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String HTTP_HEADER_ACCEPT_ENCODING> = "Accept-Encoding";

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String HTTP_HEADER_ACCEPT_LANGUAGE> = "Accept-Language";

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String HTTP_METHOD_POST> = "POST";

        <org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor: java.lang.String CONTENT_TYPE_SERIALIZED_OBJECT> = "application/x-java-serialized-object";

        return;
    }
}
