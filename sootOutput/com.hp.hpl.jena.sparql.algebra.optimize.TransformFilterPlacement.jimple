public class com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement extends com.hp.hpl.jena.sparql.algebra.TransformCopy
{
    static boolean doFilterPlacement;

    public static com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.expr.ExprList, com.hp.hpl.jena.sparql.core.BasicPattern)
    {
        com.hp.hpl.jena.sparql.core.BasicPattern r3;
        java.util.HashSet $r2;
        com.hp.hpl.jena.sparql.algebra.op.OpBGP $r6;
        com.hp.hpl.jena.sparql.expr.ExprList $r0, r1;
        com.hp.hpl.jena.sparql.algebra.Op $r4, $r5, $r7;
        boolean $z0;

        r1 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r3 := @parameter1: com.hp.hpl.jena.sparql.core.BasicPattern;

        $z0 = <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: boolean doFilterPlacement>;

        if $z0 != 0 goto label1;

        $r6 = new com.hp.hpl.jena.sparql.algebra.op.OpBGP;

        specialinvoke $r6.<com.hp.hpl.jena.sparql.algebra.op.OpBGP: void <init>(com.hp.hpl.jena.sparql.core.BasicPattern)>(r3);

        $r7 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpFilter: com.hp.hpl.jena.sparql.algebra.Op filter(com.hp.hpl.jena.sparql.expr.ExprList,com.hp.hpl.jena.sparql.algebra.Op)>(r1, $r6);

        return $r7;

     label1:
        $r0 = new com.hp.hpl.jena.sparql.expr.ExprList;

        specialinvoke $r0.<com.hp.hpl.jena.sparql.expr.ExprList: void <init>(com.hp.hpl.jena.sparql.expr.ExprList)>(r1);

        $r2 = new java.util.HashSet;

        specialinvoke $r2.<java.util.HashSet: void <init>()>();

        $r4 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterBGP(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.core.BasicPattern)>($r0, $r2, r3);

        $r5 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op buildFilter(com.hp.hpl.jena.sparql.expr.ExprList,com.hp.hpl.jena.sparql.algebra.Op)>($r0, $r4);

        return $r5;
    }

    public static com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.expr.ExprList, com.hp.hpl.jena.graph.Node, com.hp.hpl.jena.sparql.core.BasicPattern)
    {
        com.hp.hpl.jena.sparql.core.BasicPattern r4;
        com.hp.hpl.jena.graph.Node r3;
        com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern $r7;
        java.util.HashSet $r2;
        com.hp.hpl.jena.sparql.expr.ExprList $r0, r1;
        com.hp.hpl.jena.sparql.algebra.Op $r5, $r6, $r8;
        boolean $z0;

        r1 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r3 := @parameter1: com.hp.hpl.jena.graph.Node;

        r4 := @parameter2: com.hp.hpl.jena.sparql.core.BasicPattern;

        $z0 = <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: boolean doFilterPlacement>;

        if $z0 != 0 goto label1;

        $r7 = new com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern;

        specialinvoke $r7.<com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern: void <init>(com.hp.hpl.jena.graph.Node,com.hp.hpl.jena.sparql.core.BasicPattern)>(r3, r4);

        $r8 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpFilter: com.hp.hpl.jena.sparql.algebra.Op filter(com.hp.hpl.jena.sparql.expr.ExprList,com.hp.hpl.jena.sparql.algebra.Op)>(r1, $r7);

        return $r8;

     label1:
        $r0 = new com.hp.hpl.jena.sparql.expr.ExprList;

        specialinvoke $r0.<com.hp.hpl.jena.sparql.expr.ExprList: void <init>(com.hp.hpl.jena.sparql.expr.ExprList)>(r1);

        $r2 = new java.util.HashSet;

        specialinvoke $r2.<java.util.HashSet: void <init>()>();

        $r5 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterQuadPattern(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.graph.Node,com.hp.hpl.jena.sparql.core.BasicPattern)>($r0, $r2, r3, r4);

        $r6 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op buildFilter(com.hp.hpl.jena.sparql.expr.ExprList,com.hp.hpl.jena.sparql.algebra.Op)>($r0, $r5);

        return $r6;
    }

    public void <init>()
    {
        com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement r0;

        r0 := @this: com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement;

        specialinvoke r0.<com.hp.hpl.jena.sparql.algebra.TransformCopy: void <init>()>();

        return;
    }

    public com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.algebra.op.OpFilter, com.hp.hpl.jena.sparql.algebra.Op)
    {
        com.hp.hpl.jena.sparql.algebra.op.OpFilter r1;
        java.util.HashSet $r3;
        com.hp.hpl.jena.sparql.expr.ExprList $r0, $r2;
        com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement r7;
        com.hp.hpl.jena.sparql.algebra.Op r4, $r5, $r6, $r8, $r9;
        boolean $z0;

        r7 := @this: com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement;

        r1 := @parameter0: com.hp.hpl.jena.sparql.algebra.op.OpFilter;

        r4 := @parameter1: com.hp.hpl.jena.sparql.algebra.Op;

        $z0 = <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: boolean doFilterPlacement>;

        if $z0 != 0 goto label1;

        $r9 = specialinvoke r7.<com.hp.hpl.jena.sparql.algebra.TransformCopy: com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.algebra.op.OpFilter,com.hp.hpl.jena.sparql.algebra.Op)>(r1, r4);

        return $r9;

     label1:
        $r0 = new com.hp.hpl.jena.sparql.expr.ExprList;

        $r2 = virtualinvoke r1.<com.hp.hpl.jena.sparql.algebra.op.OpFilter: com.hp.hpl.jena.sparql.expr.ExprList getExprs()>();

        specialinvoke $r0.<com.hp.hpl.jena.sparql.expr.ExprList: void <init>(com.hp.hpl.jena.sparql.expr.ExprList)>($r2);

        $r3 = new java.util.HashSet;

        specialinvoke $r3.<java.util.HashSet: void <init>()>();

        $r5 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>($r0, $r3, r4);

        if $r5 != r4 goto label2;

        $r8 = specialinvoke r7.<com.hp.hpl.jena.sparql.algebra.TransformCopy: com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.algebra.op.OpFilter,com.hp.hpl.jena.sparql.algebra.Op)>(r1, r4);

        return $r8;

     label2:
        $r6 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op buildFilter(com.hp.hpl.jena.sparql.expr.ExprList,com.hp.hpl.jena.sparql.algebra.Op)>($r0, $r5);

        return $r6;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.sparql.algebra.Op)
    {
        com.hp.hpl.jena.sparql.algebra.op.OpSequence $r5, $r9;
        com.hp.hpl.jena.sparql.expr.ExprList r2;
        com.hp.hpl.jena.sparql.algebra.Op r0, $r4, $r6, $r8, $r10, $r12;
        boolean $z0, $z1, $z2, $z3, $z4;
        java.util.Set r1;
        com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern $r7;
        com.hp.hpl.jena.sparql.algebra.op.OpBGP $r11;
        com.hp.hpl.jena.sparql.algebra.op.OpConditional $r3;

        r2 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r1 := @parameter1: java.util.Set;

        r0 := @parameter2: com.hp.hpl.jena.sparql.algebra.Op;

        $z0 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpBGP;

        if $z0 == 0 goto label1;

        $r11 = (com.hp.hpl.jena.sparql.algebra.op.OpBGP) r0;

        $r12 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterBGP(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.op.OpBGP)>(r2, r1, $r11);

        return $r12;

     label1:
        $z1 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpSequence;

        if $z1 == 0 goto label2;

        $r9 = (com.hp.hpl.jena.sparql.algebra.op.OpSequence) r0;

        $r10 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterSequence(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.op.OpSequence)>(r2, r1, $r9);

        return $r10;

     label2:
        $z2 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern;

        if $z2 == 0 goto label3;

        $r7 = (com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern) r0;

        $r8 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterQuadPattern(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern)>(r2, r1, $r7);

        return $r8;

     label3:
        $z3 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpSequence;

        if $z3 == 0 goto label4;

        $r5 = (com.hp.hpl.jena.sparql.algebra.op.OpSequence) r0;

        $r6 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterSequence(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.op.OpSequence)>(r2, r1, $r5);

        return $r6;

     label4:
        $z4 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpConditional;

        if $z4 == 0 goto label5;

        $r3 = (com.hp.hpl.jena.sparql.algebra.op.OpConditional) r0;

        $r4 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterConditional(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.op.OpConditional)>(r2, r1, $r3);

        return $r4;

     label5:
        staticinvoke <com.hp.hpl.jena.sparql.algebra.OpVars: void visibleVars(com.hp.hpl.jena.sparql.algebra.Op,java.util.Set)>(r0, r1);

        return r0;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op transformFilterBGP(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.sparql.algebra.op.OpBGP)
    {
        com.hp.hpl.jena.sparql.algebra.op.OpBGP r2;
        com.hp.hpl.jena.sparql.expr.ExprList r0;
        com.hp.hpl.jena.sparql.core.BasicPattern $r3;
        java.util.Set r1;
        com.hp.hpl.jena.sparql.algebra.Op $r4;

        r0 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r1 := @parameter1: java.util.Set;

        r2 := @parameter2: com.hp.hpl.jena.sparql.algebra.op.OpBGP;

        $r3 = virtualinvoke r2.<com.hp.hpl.jena.sparql.algebra.op.OpBGP: com.hp.hpl.jena.sparql.core.BasicPattern getPattern()>();

        $r4 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterBGP(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.core.BasicPattern)>(r0, r1, $r3);

        return $r4;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op transformFilterBGP(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.sparql.core.BasicPattern)
    {
        java.util.Iterator $r3;
        com.hp.hpl.jena.sparql.core.BasicPattern r2, $r7;
        java.util.Set r1;
        com.hp.hpl.jena.graph.Triple r5;
        com.hp.hpl.jena.sparql.algebra.op.OpBGP $r6, $r8, r10;
        com.hp.hpl.jena.sparql.expr.ExprList r0;
        java.lang.Object $r4;
        com.hp.hpl.jena.sparql.algebra.Op r9;
        boolean $z0;

        r0 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r1 := @parameter1: java.util.Set;

        r2 := @parameter2: com.hp.hpl.jena.sparql.core.BasicPattern;

        r9 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r0, r1, null);

        $r3 = virtualinvoke r2.<com.hp.hpl.jena.sparql.core.BasicPattern: java.util.Iterator iterator()>();

     label1:
        $z0 = interfaceinvoke $r3.<java.util.Iterator: boolean hasNext()>();

        if $z0 == 0 goto label3;

        $r4 = interfaceinvoke $r3.<java.util.Iterator: java.lang.Object next()>();

        r5 = (com.hp.hpl.jena.graph.Triple) $r4;

        $r6 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.op.OpBGP getBGP(com.hp.hpl.jena.sparql.algebra.Op)>(r9);

        r10 = $r6;

        if $r6 != null goto label2;

        $r8 = new com.hp.hpl.jena.sparql.algebra.op.OpBGP;

        specialinvoke $r8.<com.hp.hpl.jena.sparql.algebra.op.OpBGP: void <init>()>();

        r10 = $r8;

        r9 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpSequence: com.hp.hpl.jena.sparql.algebra.Op create(com.hp.hpl.jena.sparql.algebra.Op,com.hp.hpl.jena.sparql.algebra.Op)>(r9, $r8);

     label2:
        $r7 = virtualinvoke r10.<com.hp.hpl.jena.sparql.algebra.op.OpBGP: com.hp.hpl.jena.sparql.core.BasicPattern getPattern()>();

        virtualinvoke $r7.<com.hp.hpl.jena.sparql.core.BasicPattern: void add(com.hp.hpl.jena.graph.Triple)>(r5);

        staticinvoke <com.hp.hpl.jena.sparql.util.VarUtils: void addVarsFromTriple(java.util.Collection,com.hp.hpl.jena.graph.Triple)>(r1, r5);

        r9 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r0, r1, r9);

        goto label1;

     label3:
        return r9;
    }

    private static com.hp.hpl.jena.sparql.algebra.op.OpBGP getBGP(com.hp.hpl.jena.sparql.algebra.Op)
    {
        com.hp.hpl.jena.sparql.algebra.op.OpSequence r1;
        java.util.List $r2;
        com.hp.hpl.jena.sparql.algebra.op.OpBGP $r5, $r6;
        int $i0, $i1, $i2;
        java.lang.Object $r3;
        com.hp.hpl.jena.sparql.algebra.Op r0, r4;
        boolean $z0, $z1, $z2;

        r0 := @parameter0: com.hp.hpl.jena.sparql.algebra.Op;

        $z0 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpBGP;

        if $z0 == 0 goto label1;

        $r6 = (com.hp.hpl.jena.sparql.algebra.op.OpBGP) r0;

        return $r6;

     label1:
        $z1 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpSequence;

        if $z1 == 0 goto label2;

        r1 = (com.hp.hpl.jena.sparql.algebra.op.OpSequence) r0;

        $r2 = virtualinvoke r1.<com.hp.hpl.jena.sparql.algebra.op.OpSequence: java.util.List getElements()>();

        $i0 = interfaceinvoke $r2.<java.util.List: int size()>();

        if $i0 <= 0 goto label2;

        $i1 = interfaceinvoke $r2.<java.util.List: int size()>();

        $i2 = $i1 - 1;

        $r3 = interfaceinvoke $r2.<java.util.List: java.lang.Object get(int)>($i2);

        r4 = (com.hp.hpl.jena.sparql.algebra.Op) $r3;

        $z2 = r4 instanceof com.hp.hpl.jena.sparql.algebra.op.OpBGP;

        if $z2 == 0 goto label2;

        $r5 = (com.hp.hpl.jena.sparql.algebra.op.OpBGP) r4;

        return $r5;

     label2:
        return null;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op transformFilterQuadPattern(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern)
    {
        com.hp.hpl.jena.sparql.expr.ExprList r0;
        com.hp.hpl.jena.sparql.core.BasicPattern $r4;
        java.util.Set r1;
        com.hp.hpl.jena.graph.Node $r3;
        com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern r2;
        com.hp.hpl.jena.sparql.algebra.Op $r5;

        r0 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r1 := @parameter1: java.util.Set;

        r2 := @parameter2: com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern;

        $r3 = virtualinvoke r2.<com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern: com.hp.hpl.jena.graph.Node getGraphNode()>();

        $r4 = virtualinvoke r2.<com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern: com.hp.hpl.jena.sparql.core.BasicPattern getBasicPattern()>();

        $r5 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transformFilterQuadPattern(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.graph.Node,com.hp.hpl.jena.sparql.core.BasicPattern)>(r0, r1, $r3, $r4);

        return $r5;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op transformFilterQuadPattern(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.graph.Node, com.hp.hpl.jena.sparql.core.BasicPattern)
    {
        com.hp.hpl.jena.graph.Node r2;
        com.hp.hpl.jena.sparql.expr.ExprList r0;
        com.hp.hpl.jena.sparql.algebra.Op r12;
        boolean $z0, $z1;
        java.util.Iterator $r4;
        com.hp.hpl.jena.sparql.core.BasicPattern r3, $r8, $r10;
        java.util.Set r1;
        com.hp.hpl.jena.sparql.core.Var $r11;
        com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern $r7, $r9, r13;
        com.hp.hpl.jena.graph.Triple r6;
        java.lang.Object $r5;

        r0 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r1 := @parameter1: java.util.Set;

        r2 := @parameter2: com.hp.hpl.jena.graph.Node;

        r3 := @parameter3: com.hp.hpl.jena.sparql.core.BasicPattern;

        r12 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r0, r1, null);

        $z0 = staticinvoke <com.hp.hpl.jena.sparql.core.Var: boolean isVar(com.hp.hpl.jena.graph.Node)>(r2);

        if $z0 == 0 goto label1;

        $r11 = staticinvoke <com.hp.hpl.jena.sparql.core.Var: com.hp.hpl.jena.sparql.core.Var alloc(com.hp.hpl.jena.graph.Node)>(r2);

        staticinvoke <com.hp.hpl.jena.sparql.util.VarUtils: void addVar(java.util.Collection,com.hp.hpl.jena.graph.Node)>(r1, $r11);

     label1:
        $r4 = virtualinvoke r3.<com.hp.hpl.jena.sparql.core.BasicPattern: java.util.Iterator iterator()>();

     label2:
        $z1 = interfaceinvoke $r4.<java.util.Iterator: boolean hasNext()>();

        if $z1 == 0 goto label4;

        $r5 = interfaceinvoke $r4.<java.util.Iterator: java.lang.Object next()>();

        r6 = (com.hp.hpl.jena.graph.Triple) $r5;

        $r7 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern getQuads(com.hp.hpl.jena.sparql.algebra.Op)>(r12);

        r13 = $r7;

        if $r7 != null goto label3;

        $r9 = new com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern;

        $r10 = new com.hp.hpl.jena.sparql.core.BasicPattern;

        specialinvoke $r10.<com.hp.hpl.jena.sparql.core.BasicPattern: void <init>()>();

        specialinvoke $r9.<com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern: void <init>(com.hp.hpl.jena.graph.Node,com.hp.hpl.jena.sparql.core.BasicPattern)>(r2, $r10);

        r13 = $r9;

        r12 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpSequence: com.hp.hpl.jena.sparql.algebra.Op create(com.hp.hpl.jena.sparql.algebra.Op,com.hp.hpl.jena.sparql.algebra.Op)>(r12, $r9);

     label3:
        $r8 = virtualinvoke r13.<com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern: com.hp.hpl.jena.sparql.core.BasicPattern getBasicPattern()>();

        virtualinvoke $r8.<com.hp.hpl.jena.sparql.core.BasicPattern: void add(com.hp.hpl.jena.graph.Triple)>(r6);

        staticinvoke <com.hp.hpl.jena.sparql.util.VarUtils: void addVarsFromTriple(java.util.Collection,com.hp.hpl.jena.graph.Triple)>(r1, r6);

        r12 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r0, r1, r12);

        goto label2;

     label4:
        return r12;
    }

    private static com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern getQuads(com.hp.hpl.jena.sparql.algebra.Op)
    {
        com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern $r5, $r6;
        com.hp.hpl.jena.sparql.algebra.op.OpSequence r1;
        java.util.List $r2;
        int $i0, $i1, $i2;
        java.lang.Object $r3;
        com.hp.hpl.jena.sparql.algebra.Op r0, r4;
        boolean $z0, $z1, $z2;

        r0 := @parameter0: com.hp.hpl.jena.sparql.algebra.Op;

        $z0 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern;

        if $z0 == 0 goto label1;

        $r6 = (com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern) r0;

        return $r6;

     label1:
        $z1 = r0 instanceof com.hp.hpl.jena.sparql.algebra.op.OpSequence;

        if $z1 == 0 goto label2;

        r1 = (com.hp.hpl.jena.sparql.algebra.op.OpSequence) r0;

        $r2 = virtualinvoke r1.<com.hp.hpl.jena.sparql.algebra.op.OpSequence: java.util.List getElements()>();

        $i0 = interfaceinvoke $r2.<java.util.List: int size()>();

        if $i0 <= 0 goto label2;

        $i1 = interfaceinvoke $r2.<java.util.List: int size()>();

        $i2 = $i1 - 1;

        $r3 = interfaceinvoke $r2.<java.util.List: java.lang.Object get(int)>($i2);

        r4 = (com.hp.hpl.jena.sparql.algebra.Op) $r3;

        $z2 = r4 instanceof com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern;

        if $z2 == 0 goto label2;

        $r5 = (com.hp.hpl.jena.sparql.algebra.op.OpQuadPattern) r4;

        return $r5;

     label2:
        return null;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op transformFilterSequence(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.sparql.algebra.op.OpSequence)
    {
        java.util.Iterator $r4;
        java.util.Set r3;
        com.hp.hpl.jena.sparql.algebra.op.OpSequence r0;
        java.util.List $r1;
        com.hp.hpl.jena.sparql.expr.ExprList r2;
        java.lang.Object $r5;
        com.hp.hpl.jena.sparql.algebra.Op $r6, $r7, r8, r9;
        boolean $z0;

        r2 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r3 := @parameter1: java.util.Set;

        r0 := @parameter2: com.hp.hpl.jena.sparql.algebra.op.OpSequence;

        $r1 = virtualinvoke r0.<com.hp.hpl.jena.sparql.algebra.op.OpSequence: java.util.List getElements()>();

        r8 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r2, r3, null);

        $r4 = interfaceinvoke $r1.<java.util.List: java.util.Iterator iterator()>();

     label1:
        $z0 = interfaceinvoke $r4.<java.util.Iterator: boolean hasNext()>();

        if $z0 == 0 goto label2;

        $r5 = interfaceinvoke $r4.<java.util.Iterator: java.lang.Object next()>();

        r9 = (com.hp.hpl.jena.sparql.algebra.Op) $r5;

        $r6 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r2, r3, r9);

        $r7 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpSequence: com.hp.hpl.jena.sparql.algebra.Op create(com.hp.hpl.jena.sparql.algebra.Op,com.hp.hpl.jena.sparql.algebra.Op)>(r8, $r6);

        r8 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r2, r3, $r7);

        goto label1;

     label2:
        return r8;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op transformFilterConditional(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.sparql.algebra.op.OpConditional)
    {
        java.util.Set r1;
        com.hp.hpl.jena.sparql.expr.ExprList r0;
        com.hp.hpl.jena.sparql.algebra.op.OpConditional r2, $r6;
        com.hp.hpl.jena.sparql.algebra.Op $r3, $r4, $r5, $r7;

        r0 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r1 := @parameter1: java.util.Set;

        r2 := @parameter2: com.hp.hpl.jena.sparql.algebra.op.OpConditional;

        staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r0, r1, null);

        $r3 = virtualinvoke r2.<com.hp.hpl.jena.sparql.algebra.op.OpConditional: com.hp.hpl.jena.sparql.algebra.Op getLeft()>();

        $r4 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op transform(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r0, r1, $r3);

        $r5 = virtualinvoke r2.<com.hp.hpl.jena.sparql.algebra.op.OpConditional: com.hp.hpl.jena.sparql.algebra.Op getRight()>();

        $r6 = new com.hp.hpl.jena.sparql.algebra.op.OpConditional;

        specialinvoke $r6.<com.hp.hpl.jena.sparql.algebra.op.OpConditional: void <init>(com.hp.hpl.jena.sparql.algebra.Op,com.hp.hpl.jena.sparql.algebra.Op)>($r4, $r5);

        $r7 = staticinvoke <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList,java.util.Set,com.hp.hpl.jena.sparql.algebra.Op)>(r0, r1, $r6);

        return $r7;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op insertAnyFilter(com.hp.hpl.jena.sparql.expr.ExprList, java.util.Set, com.hp.hpl.jena.sparql.algebra.Op)
    {
        java.util.Iterator $r1;
        java.util.Set $r4, r5;
        com.hp.hpl.jena.sparql.expr.Expr r3;
        com.hp.hpl.jena.sparql.expr.ExprList r0;
        java.lang.Object $r2;
        com.hp.hpl.jena.sparql.algebra.Op r6;
        boolean $z0, $z1;

        r0 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r5 := @parameter1: java.util.Set;

        r6 := @parameter2: com.hp.hpl.jena.sparql.algebra.Op;

        $r1 = virtualinvoke r0.<com.hp.hpl.jena.sparql.expr.ExprList: java.util.Iterator iterator()>();

     label1:
        $z0 = interfaceinvoke $r1.<java.util.Iterator: boolean hasNext()>();

        if $z0 == 0 goto label4;

        $r2 = interfaceinvoke $r1.<java.util.Iterator: java.lang.Object next()>();

        r3 = (com.hp.hpl.jena.sparql.expr.Expr) $r2;

        $r4 = interfaceinvoke r3.<com.hp.hpl.jena.sparql.expr.Expr: java.util.Set getVarsMentioned()>();

        $z1 = interfaceinvoke r5.<java.util.Set: boolean containsAll(java.util.Collection)>($r4);

        if $z1 == 0 goto label3;

        if r6 != null goto label2;

        r6 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpTable: com.hp.hpl.jena.sparql.algebra.op.OpTable unit()>();

     label2:
        r6 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpFilter: com.hp.hpl.jena.sparql.algebra.Op filter(com.hp.hpl.jena.sparql.expr.Expr,com.hp.hpl.jena.sparql.algebra.Op)>(r3, r6);

        interfaceinvoke $r1.<java.util.Iterator: void remove()>();

     label3:
        goto label1;

     label4:
        return r6;
    }

    private static com.hp.hpl.jena.sparql.algebra.Op buildFilter(com.hp.hpl.jena.sparql.expr.ExprList, com.hp.hpl.jena.sparql.algebra.Op)
    {
        java.util.Iterator $r1;
        com.hp.hpl.jena.sparql.expr.Expr r3;
        com.hp.hpl.jena.sparql.expr.ExprList r0;
        java.lang.Object $r2;
        com.hp.hpl.jena.sparql.algebra.Op r4;
        boolean $z0, $z1;

        r0 := @parameter0: com.hp.hpl.jena.sparql.expr.ExprList;

        r4 := @parameter1: com.hp.hpl.jena.sparql.algebra.Op;

        $z0 = virtualinvoke r0.<com.hp.hpl.jena.sparql.expr.ExprList: boolean isEmpty()>();

        if $z0 == 0 goto label1;

        return r4;

     label1:
        $r1 = virtualinvoke r0.<com.hp.hpl.jena.sparql.expr.ExprList: java.util.Iterator iterator()>();

     label2:
        $z1 = interfaceinvoke $r1.<java.util.Iterator: boolean hasNext()>();

        if $z1 == 0 goto label4;

        $r2 = interfaceinvoke $r1.<java.util.Iterator: java.lang.Object next()>();

        r3 = (com.hp.hpl.jena.sparql.expr.Expr) $r2;

        if r4 != null goto label3;

        r4 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpTable: com.hp.hpl.jena.sparql.algebra.op.OpTable unit()>();

     label3:
        r4 = staticinvoke <com.hp.hpl.jena.sparql.algebra.op.OpFilter: com.hp.hpl.jena.sparql.algebra.Op filter(com.hp.hpl.jena.sparql.expr.Expr,com.hp.hpl.jena.sparql.algebra.Op)>(r3, r4);

        interfaceinvoke $r1.<java.util.Iterator: void remove()>();

        goto label2;

     label4:
        return r4;
    }

    static void <clinit>()
    {
        <com.hp.hpl.jena.sparql.algebra.optimize.TransformFilterPlacement: boolean doFilterPlacement> = 1;

        return;
    }
}
