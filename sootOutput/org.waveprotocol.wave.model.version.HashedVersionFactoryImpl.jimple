public class org.waveprotocol.wave.model.version.HashedVersionFactoryImpl extends org.waveprotocol.wave.model.version.HashedVersionZeroFactoryImpl
{
    private static final int HASH_SIZE_BITS;
    static int hashSizeBits;

    public void <init>(org.waveprotocol.wave.model.id.IdURIEncoderDecoder)
    {
        org.waveprotocol.wave.model.version.HashedVersionFactoryImpl r0;
        org.waveprotocol.wave.model.id.IdURIEncoderDecoder r1;

        r0 := @this: org.waveprotocol.wave.model.version.HashedVersionFactoryImpl;

        r1 := @parameter0: org.waveprotocol.wave.model.id.IdURIEncoderDecoder;

        specialinvoke r0.<org.waveprotocol.wave.model.version.HashedVersionZeroFactoryImpl: void <init>(org.waveprotocol.wave.model.id.IdURIEncoderDecoder)>(r1);

        return;
    }

    private static byte[] calculateHash(byte[], byte[])
    {
        byte[] r0, r1, r2, $r4, r7;
        java.security.MessageDigest $r3;
        int $i0, $i1, $i2, $i3, $i4, $i5, $i6, $i7, $i8;
        java.lang.RuntimeException $r6;
        java.security.NoSuchAlgorithmException $r5;

        r7 := @parameter0: byte[];

        r0 := @parameter1: byte[];

        $i1 = lengthof r0;

        $i0 = lengthof r7;

        $i2 = $i1 + $i0;

        r1 = newarray (byte)[$i2];

        $i3 = <org.waveprotocol.wave.model.version.HashedVersionFactoryImpl: int hashSizeBits>;

        $i4 = $i3 / 8;

        r2 = newarray (byte)[$i4];

        $i5 = lengthof r7;

        staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(r7, 0, r1, 0, $i5);

        $i7 = lengthof r7;

        $i6 = lengthof r0;

        staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(r0, 0, r1, $i7, $i6);

     label1:
        $r3 = staticinvoke <java.security.MessageDigest: java.security.MessageDigest getInstance(java.lang.String)>("SHA-256");

        $r4 = virtualinvoke $r3.<java.security.MessageDigest: byte[] digest(byte[])>(r1);

     label2:
        goto label4;

     label3:
        $r5 := @caughtexception;

        $r6 = new java.lang.RuntimeException;

        specialinvoke $r6.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>($r5);

        throw $r6;

     label4:
        $i8 = lengthof r2;

        staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>($r4, 0, r2, 0, $i8);

        return r2;

        catch java.security.NoSuchAlgorithmException from label1 to label2 with label3;
    }

    public org.waveprotocol.wave.model.version.HashedVersion create(byte[], org.waveprotocol.wave.model.version.HashedVersion, int)
    {
        byte[] $r1, r2, $r3;
        long $l0, $l2, $l3;
        org.waveprotocol.wave.model.version.HashedVersionFactoryImpl r5;
        org.waveprotocol.wave.model.version.HashedVersion r0, $r4;
        int i1;

        r5 := @this: org.waveprotocol.wave.model.version.HashedVersionFactoryImpl;

        r2 := @parameter0: byte[];

        r0 := @parameter1: org.waveprotocol.wave.model.version.HashedVersion;

        i1 := @parameter2: int;

        $l0 = virtualinvoke r0.<org.waveprotocol.wave.model.version.HashedVersion: long getVersion()>();

        $l2 = (long) i1;

        $l3 = $l0 + $l2;

        $r1 = virtualinvoke r0.<org.waveprotocol.wave.model.version.HashedVersion: byte[] getHistoryHash()>();

        $r3 = staticinvoke <org.waveprotocol.wave.model.version.HashedVersionFactoryImpl: byte[] calculateHash(byte[],byte[])>($r1, r2);

        $r4 = staticinvoke <org.waveprotocol.wave.model.version.HashedVersion: org.waveprotocol.wave.model.version.HashedVersion of(long,byte[])>($l3, $r3);

        return $r4;
    }

    static void <clinit>()
    {
        <org.waveprotocol.wave.model.version.HashedVersionFactoryImpl: int HASH_SIZE_BITS> = 160;

        <org.waveprotocol.wave.model.version.HashedVersionFactoryImpl: int hashSizeBits> = 160;

        return;
    }
}
