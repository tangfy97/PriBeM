public abstract class kodkod.engine.bool.Int extends java.lang.Object
{
    final kodkod.engine.bool.BooleanFactory factory;

    void <init>(kodkod.engine.bool.BooleanFactory)
    {
        kodkod.engine.bool.Int r0;
        kodkod.engine.bool.BooleanFactory r1;

        r0 := @this: kodkod.engine.bool.Int;

        r1 := @parameter0: kodkod.engine.bool.BooleanFactory;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        r0.<kodkod.engine.bool.Int: kodkod.engine.bool.BooleanFactory factory> = r1;

        return;
    }

    final void validate(kodkod.engine.bool.Int)
    {
        kodkod.engine.bool.Int r0, r1;
        kodkod.engine.bool.BooleanFactory $r2, $r3;
        java.lang.IllegalArgumentException $r4;

        r1 := @this: kodkod.engine.bool.Int;

        r0 := @parameter0: kodkod.engine.bool.Int;

        $r3 = r0.<kodkod.engine.bool.Int: kodkod.engine.bool.BooleanFactory factory>;

        $r2 = r1.<kodkod.engine.bool.Int: kodkod.engine.bool.BooleanFactory factory>;

        if $r3 == $r2 goto label1;

        $r4 = new java.lang.IllegalArgumentException;

        specialinvoke $r4.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("other.factory != this.factory");

        throw $r4;

     label1:
        return;
    }

    abstract kodkod.engine.bool.BooleanValue bit(int);

    public abstract java.util.List twosComplementBits();

    public final kodkod.engine.bool.BooleanFactory factory()
    {
        kodkod.engine.bool.Int r0;
        kodkod.engine.bool.BooleanFactory $r1;

        r0 := @this: kodkod.engine.bool.Int;

        $r1 = r0.<kodkod.engine.bool.Int: kodkod.engine.bool.BooleanFactory factory>;

        return $r1;
    }

    public abstract int width();

    public abstract boolean isConstant();

    public abstract int value();

    public abstract kodkod.engine.bool.BooleanValue eq(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.BooleanValue lte(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.BooleanValue lt(kodkod.engine.bool.Int);

    public kodkod.engine.bool.BooleanValue gte(kodkod.engine.bool.Int)
    {
        kodkod.engine.bool.BooleanValue $r2;
        kodkod.engine.bool.Int r0, r1;

        r1 := @this: kodkod.engine.bool.Int;

        r0 := @parameter0: kodkod.engine.bool.Int;

        $r2 = virtualinvoke r0.<kodkod.engine.bool.Int: kodkod.engine.bool.BooleanValue lte(kodkod.engine.bool.Int)>(r1);

        return $r2;
    }

    public kodkod.engine.bool.BooleanValue gt(kodkod.engine.bool.Int)
    {
        kodkod.engine.bool.BooleanValue $r2;
        kodkod.engine.bool.Int r0, r1;

        r1 := @this: kodkod.engine.bool.Int;

        r0 := @parameter0: kodkod.engine.bool.Int;

        $r2 = virtualinvoke r0.<kodkod.engine.bool.Int: kodkod.engine.bool.BooleanValue lt(kodkod.engine.bool.Int)>(r1);

        return $r2;
    }

    public abstract kodkod.engine.bool.Int plus(kodkod.engine.bool.Int);

    public abstract transient kodkod.engine.bool.Int plus(kodkod.engine.bool.Int[]);

    public abstract kodkod.engine.bool.Int multiply(kodkod.engine.bool.Int);

    public abstract transient kodkod.engine.bool.Int multiply(kodkod.engine.bool.Int[]);

    public abstract kodkod.engine.bool.Int minus(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int divide(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int modulo(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int choice(kodkod.engine.bool.BooleanValue, kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int and(kodkod.engine.bool.Int);

    public abstract transient kodkod.engine.bool.Int and(kodkod.engine.bool.Int[]);

    public abstract kodkod.engine.bool.Int or(kodkod.engine.bool.Int);

    public abstract transient kodkod.engine.bool.Int or(kodkod.engine.bool.Int[]);

    public abstract kodkod.engine.bool.Int xor(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int shl(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int shr(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int sha(kodkod.engine.bool.Int);

    public abstract kodkod.engine.bool.Int negate();

    public abstract kodkod.engine.bool.Int not();

    public abstract kodkod.engine.bool.Int abs();

    public abstract kodkod.engine.bool.Int sgn();
}
